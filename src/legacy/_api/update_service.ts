/* tslint:disable:array-type */
/* tslint:disable:no-namespace */
/* tslint:disable:no-string-literal */
/* tslint:disable:max-classes-per-file */
/* tslint:disable:no-trailing-whitespace */

// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================

/**
 * Update Service API
 * This is the API documentation for the Mbed deployment service, which is part of the update service.
 *
 * OpenAPI spec version: 3
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as superagent from "superagent";
import { ApiBase } from "../common/apiBase";
import { SDKError } from "../common/sdkError";

export namespace CampaignDeviceMetadata {
    export type DeploymentStateEnum =
        | "pending"
        | "updated_connector_channel"
        | "failed_connector_channel_update"
        | "deployed"
        | "manifestremoved"
        | "deregistered";
}
export interface CampaignDeviceMetadata {
    /**
     * The device's campaign ID
     */
    campaign?: string;
    /**
     * The time the campaign was created
     */
    created_at?: Date;
    /**
     * The state of the update campaign on the device
     */
    deployment_state?: CampaignDeviceMetadata.DeploymentStateEnum;
    /**
     * Description
     */
    description?: string;
    /**
     * The device ID
     */
    device_id?: string;
    /**
     * API resource entity version
     */
    etag?: string;
    /**
     * The metadata record ID
     */
    id?: string;
    /**
     * How the firmware is delivered (connector or direct)
     */
    mechanism?: string;
    /**
     * The Cloud Connect URL
     */
    mechanism_url?: string;
    /**
     * The record name
     */
    name?: string;
    /**
     * Entity name: always 'update-campaign-device-metadata'
     */
    object?: string;
    /**
     * This time this record was modified in the database format: date-time
     */
    updated_at?: Date;
}

export namespace CampaignDeviceMetadataPage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface CampaignDeviceMetadataPage {
    /**
     * The entity ID to fetch after the given one
     */
    after?: string;
    /**
     * A list of entities
     */
    data?: Array<CampaignDeviceMetadata>;
    /**
     * Flag indicating whether there are more results
     */
    has_more?: boolean;
    /**
     * The number of results to return, (range: 2-1000), or equals to total_count
     */
    limit?: number;
    /**
     * Entity name: always 'list'
     */
    object?: string;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    order?: CampaignDeviceMetadataPage.OrderEnum;
    /**
     * The total number or records, if requested. It might be returned also for small lists.
     */
    total_count?: number;
}

export interface FirmwareImage {
    /**
     * The time the object was created
     */
    created_at: Date;
    /**
     * The firmware image file URL
     */
    datafile: string;
    /**
     * Checksum (sha256) generated for the datafile
     */
    datafile_checksum: string;
    /**
     * Size of the datafile in bytes
     */
    datafile_size?: number;
    /**
     * The description of the object
     */
    description: string;
    /**
     * The entity instance signature
     */
    etag: Date;
    /**
     * The firmware image ID
     */
    id: string;
    /**
     * The firmware image name
     */
    name: string;
    /**
     * The API resource entity
     */
    object: string;
    /**
     * The time the object was updated
     */
    updated_at: Date;
}

export interface FirmwareImageEqNeqFilter {
    created_at?: Date;
    datafile?: string;
    datafile_checksum?: string;
    datafile_size?: number;
    description?: string;
    etag?: Date;
    id?: string;
    name?: string;
    updated_at?: Date;
}

export interface FirmwareImageGteLteFilter {
    created_at?: Date;
    etag?: Date;
    updated_at?: Date;
}

export interface FirmwareImageInNinFilter {
    created_at?: Date;
    datafile?: string;
    datafile_checksum?: string;
    datafile_size?: number;
    description?: string;
    etag?: Date;
    id?: string;
    name?: string;
    updated_at?: Date;
}

export namespace FirmwareImagePage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface FirmwareImagePage {
    after?: string;
    data?: Array<FirmwareImage>;
    has_more?: boolean;
    limit?: number;
    object?: string;
    /**
     * The order of the records based on creation time, `ASC` or `DESC`; by default `ASC`.
     */
    order?: FirmwareImagePage.OrderEnum;
    total_count?: number;
}

export interface FirmwareManifest {
    /**
     * The time the object was created
     */
    created_at: Date;
    /**
     * The URL of the firmware manifest binary
     */
    datafile: string;
    /**
     * Size of the datafile in bytes
     */
    datafile_size?: number;
    /**
     * The description of the firmware manifest
     */
    description: string;
    /**
     * The class of the device
     */
    device_class: string;
    /**
     * The entity instance signature
     */
    etag: Date;
    /**
     * The firmware manifest ID
     */
    id: string;
    /**
     * The key table of pre-shared keys for devices
     */
    key_table?: string;
    /**
     * The name of the object
     */
    name: string;
    /**
     * The API resource entity
     */
    object: string;
    /**
     * The firmware manifest version as a timestamp
     */
    timestamp: Date;
    /**
     * The time the object was updated
     */
    updated_at: Date;
}

export interface FirmwareManifestEqNeqFilter {
    created_at?: Date;
    datafile?: string;
    datafile_size?: number;
    description?: string;
    device_class?: string;
    etag?: Date;
    id?: string;
    name?: string;
    timestamp?: Date;
    updated_at?: Date;
}

export interface FirmwareManifestGteLteFilter {
    created_at?: Date;
    etag?: Date;
    timestamp?: Date;
    updated_at?: Date;
}

export interface FirmwareManifestInNinFilter {
    created_at?: Date;
    datafile?: string;
    datafile_size?: number;
    description?: string;
    device_class?: string;
    etag?: Date;
    id?: string;
    name?: string;
    timestamp?: Date;
    updated_at?: Date;
}

export namespace FirmwareManifestPage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface FirmwareManifestPage {
    after?: string;
    data?: Array<FirmwareManifest>;
    has_more?: boolean;
    limit?: number;
    object?: string;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    order?: FirmwareManifestPage.OrderEnum;
    total_count?: number;
}

export namespace UpdateCampaign {
    export type StateEnum =
        | "draft"
        | "scheduled"
        | "allocatingquota"
        | "allocatedquota"
        | "quotaallocationfailed"
        | "checkingmanifest"
        | "checkedmanifest"
        | "devicefetch"
        | "devicecopy"
        | "devicecheck"
        | "publishing"
        | "deploying"
        | "deployed"
        | "manifestremoved"
        | "expired"
        | "stopping"
        | "autostopped"
        | "userstopped"
        | "conflict";
}
export interface UpdateCampaign {
    /**
     * The time the update campaign was created
     */
    created_at?: Date;
    /**
     * The optional description of the campaign
     */
    description?: string;
    /**
     * The filter for the devices the campaign will target
     */
    device_filter?: string;
    /**
     * The entity instance signature
     */
    etag?: string;
    /**
     * The campaign finish timestamp
     */
    finished?: Date;
    /**
     * The campaign ID
     */
    id?: string;
    /**
     * The campaign name
     */
    name?: string;
    /**
     * The API resource entity
     */
    object?: string;
    /**
     * The current phase of the campaign.
     */
    phase?: string;
    root_manifest_id?: string;
    root_manifest_url?: string;
    started_at?: Date;
    /**
     * The state of the campaign
     */
    state?: UpdateCampaign.StateEnum;
    /**
     * The time the object was updated
     */
    updated_at?: Date;
    /**
     * The scheduled start time for the update campaign
     */
    when?: Date;
}

export interface UpdateCampaignEqNeqFilter {
    created_at?: Date;
    description?: string;
    device_filter?: string;
    etag?: Date;
    finished?: Date;
    id?: string;
    name?: string;
    root_manifest_id?: string;
    started_at?: Date;
    state?: string;
    updated_at?: Date;
    when?: Date;
}

export interface UpdateCampaignGteLteFilter {
    created_at?: Date;
    etag?: Date;
    finished?: Date;
    started_at?: Date;
    updated_at?: Date;
    when?: Date;
}

export interface UpdateCampaignInNinFilter {
    created_at?: Date;
    description?: string;
    device_filter?: string;
    etag?: Date;
    finished?: Date;
    id?: string;
    name?: string;
    root_manifest_id?: string;
    started_at?: Date;
    state?: string;
    updated_at?: Date;
    when?: Date;
}

export namespace UpdateCampaignPage {
    export type OrderEnum = "ASC" | "DESC";
}
export interface UpdateCampaignPage {
    after?: string;
    data?: Array<UpdateCampaign>;
    has_more?: boolean;
    limit?: number;
    object?: string;
    /**
     * The order of the records to return. Acceptable values: ASC, DESC. Default: ASC
     */
    order?: UpdateCampaignPage.OrderEnum;
    total_count?: number;
}

export namespace UpdateCampaignPatchRequest {
    export type StateEnum =
        | "draft"
        | "scheduled"
        | "allocatingquota"
        | "allocatedquota"
        | "quotaallocationfailed"
        | "checkingmanifest"
        | "checkedmanifest"
        | "devicefetch"
        | "devicecopy"
        | "devicecheck"
        | "publishing"
        | "deploying"
        | "deployed"
        | "manifestremoved"
        | "expired"
        | "stopping"
        | "autostopped"
        | "userstopped"
        | "conflict";
}
export interface UpdateCampaignPatchRequest {
    /**
     * The optional description of the campaign
     */
    description?: string;
    /**
     * The filter for the devices the campaign will target
     */
    device_filter?: string;
    /**
     * The campaign name
     */
    name?: string;
    /**
     * The API resource entity
     */
    object?: string;
    root_manifest_id?: string;
    /**
     * The state of the campaign
     */
    state?: UpdateCampaignPatchRequest.StateEnum;
    /**
     * The scheduled start time for the update campaign
     */
    when?: Date;
}

export namespace UpdateCampaignPostRequest {
    export type StateEnum =
        | "draft"
        | "scheduled"
        | "allocatingquota"
        | "allocatedquota"
        | "quotaallocationfailed"
        | "checkingmanifest"
        | "checkedmanifest"
        | "devicefetch"
        | "devicecopy"
        | "devicecheck"
        | "publishing"
        | "deploying"
        | "deployed"
        | "manifestremoved"
        | "expired"
        | "stopping"
        | "autostopped"
        | "userstopped"
        | "conflict";
}
export interface UpdateCampaignPostRequest {
    /**
     * The optional description of the campaign
     */
    description?: string;
    /**
     * The filter for the devices the campaign will target
     */
    device_filter: string;
    /**
     * The name for this campaign
     */
    name: string;
    /**
     * The API resource entity
     */
    object?: string;
    root_manifest_id?: string;
    /**
     * The state of the campaign
     */
    state?: UpdateCampaignPostRequest.StateEnum;
    /**
     * The scheduled start time for the update campaign
     */
    when?: Date;
}

export namespace UpdateCampaignPutRequest {
    export type StateEnum =
        | "draft"
        | "scheduled"
        | "allocatingquota"
        | "allocatedquota"
        | "quotaallocationfailed"
        | "checkingmanifest"
        | "checkedmanifest"
        | "devicefetch"
        | "devicecopy"
        | "devicecheck"
        | "publishing"
        | "deploying"
        | "deployed"
        | "manifestremoved"
        | "expired"
        | "stopping"
        | "autostopped"
        | "userstopped"
        | "conflict";
}
export interface UpdateCampaignPutRequest {
    /**
     * An optional description of the campaign
     */
    description: string;
    /**
     * The filter for the devices the campaign will target
     */
    device_filter: string;
    /**
     * The campaign's name
     */
    name: string;
    /**
     * The API resource entity
     */
    object: string;
    root_manifest_id: string;
    /**
     * The state of the campaign
     */
    state: UpdateCampaignPutRequest.StateEnum;
    /**
     * The scheduled start time for the update campaign
     */
    when: Date;
}

/**
 * DefaultApi
 */
export class DefaultApi extends ApiBase {
    /**
     * Create an image
     * Create firmware image.
     * @param datafile The firmware image file to upload
     * @param name The name of the firmware image
     * @param description The description of the firmware image
     */
    public firmwareImageCreate(
        datafile: any,
        name: string,
        description?: string,
        callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "datafile" is set
        if (datafile === null || datafile === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'datafile' missing."));
            }
            return;
        }
        // verify required parameter "name" is set
        if (name === null || name === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'name' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        if (datafile !== undefined) {
            formParams["datafile"] = datafile;
        }
        useFormData = true;

        if (description !== undefined) {
            formParams["description"] = description;
        }

        if (name !== undefined) {
            formParams["name"] = name;
        }

        // Determine the Content-Type header
        const contentTypes: Array<string> = ["multipart/form-data"];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<FirmwareImage>(
            {
                url: "/v3/firmware-images/",
                method: "POST",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Delete an image
     * Delete firmware image.
     * @param imageId The firmware image ID
     */
    public firmwareImageDestroy(
        imageId: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "imageId" is set
        if (imageId === null || imageId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'imageId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<null>(
            {
                url: "/v3/firmware-images/{image_id}/".replace("{" + "image_id" + "}", String(imageId)),
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * List all images
     * List all firmware images.
     * @param limit How many firmware images to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data  &#x60;?filter&#x3D;{URL-encoded query string}&#x60;  ###### Filterable fields:  The below table lists all the fields that can be filtered on with certain filters:  |       Field       | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:-----------------:|:----------------:|:-------------:|:-------------:| |     created_at    |         ✓        |       ✓       |       ✓       | |      datafile     |         ✓        |       ✓       |               | | datafile_checksum |         ✓        |       ✓       |               | |   datafile_size   |         ✓        |       ✓       |               | |    description    |         ✓        |       ✓       |               | |        etag       |         ✓        |       ✓       |       ✓       | |         id        |         ✓        |       ✓       |               | |        name       |         ✓        |       ✓       |               | |     timestamp     |         ✓        |       ✓       |       ✓       | |     updated_at    |         ✓        |       ✓       |       ✓       |  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3&#x60;  would be URL-encoded as: &#x60;?filter&#x3D;key1__eq%3Dvalue1%26key2__eq%3Dvalue2%26key3__eq%3Dvalue3&#x60;   **Filtering by properties** &#x60;name__eq&#x3D;myimage&#x60;  **Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality by appending &#x60;__eq&#x60; to the field name * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;{field name}[|__eq|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering on multiple fields**  &#x60;name__eq&#x3D;myimage&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering with filter operators**  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__in&#x3D;fw-image1,fw-image2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public firmwareImageList(
        limit?: number,
        order?: string,
        after?: string,
        filter?: string,
        include?: string,
        callback?: (error: any, data?: FirmwareImagePage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<FirmwareImagePage>(
            {
                url: "/v3/firmware-images/",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Get an image
     * Retrieve firmware image.
     * @param imageId The firmware image ID
     */
    public firmwareImageRetrieve(
        imageId: string,
        callback?: (error: any, data?: FirmwareImage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "imageId" is set
        if (imageId === null || imageId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'imageId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<FirmwareImage>(
            {
                url: "/v3/firmware-images/{image_id}/".replace("{" + "image_id" + "}", String(imageId)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Create a manifest
     * Create firmware manifest.
     * @param datafile The manifest file to create. The API gateway enforces the account-specific file size.
     * @param name The name of the firmware manifest
     * @param description The description of the firmware manifest
     * @param keyTable The key table of pre-shared keys for devices
     */
    public firmwareManifestCreate(
        datafile: any,
        name: string,
        description?: string,
        keyTable?: any,
        callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "datafile" is set
        if (datafile === null || datafile === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'datafile' missing."));
            }
            return;
        }
        // verify required parameter "name" is set
        if (name === null || name === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'name' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        if (datafile !== undefined) {
            formParams["datafile"] = datafile;
        }
        useFormData = true;

        if (description !== undefined) {
            formParams["description"] = description;
        }

        if (keyTable !== undefined) {
            formParams["key_table"] = keyTable;
        }
        useFormData = true;

        if (name !== undefined) {
            formParams["name"] = name;
        }

        // Determine the Content-Type header
        const contentTypes: Array<string> = ["multipart/form-data"];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<FirmwareManifest>(
            {
                url: "/v3/firmware-manifests/",
                method: "POST",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Delete a manifest
     * Delete firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    public firmwareManifestDestroy(
        manifestId: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "manifestId" is set
        if (manifestId === null || manifestId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'manifestId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<null>(
            {
                url: "/v3/firmware-manifests/{manifest_id}/".replace("{" + "manifest_id" + "}", String(manifestId)),
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * List manifests
     * List firmware manifests.
     * @param limit How many firmware manifests to retrieve
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page.
     * @param filter URL-encoded query string parameter to filter returned data  &#x60;?filter&#x3D;{URL-encoded query string}&#x60;  ###### Filterable fields:  The below table lists all the fields that can be filtered on with certain filters:  |     Field     | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:-------------:|:----------------:|:-------------:|:-------------:| |   created_at  |         ✓        |       ✓       |       ✓       | |    datafile   |         ✓        |       ✓       |               | | datafile_size |         ✓        |       ✓       |               | |  description  |         ✓        |       ✓       |               | |  device_class |         ✓        |       ✓       |               | |      etag     |         ✓        |       ✓       |       ✓       | |       id      |         ✓        |       ✓       |               | |      name     |         ✓        |       ✓       |               | |   timestamp   |         ✓        |       ✓       |       ✓       | |   updated_at  |         ✓        |       ✓       |       ✓       |  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;key1__eq&#x3D;value1&amp;key2__eq&#x3D;value2&amp;key3__eq&#x3D;value3&#x60;  would be URL-encoded as: &#x60;?filter&#x3D;key1__eq%3Dvalue1%26key2__eq%3Dvalue2%26key3__eq%3Dvalue3&#x60;   **Filtering by properties** &#x60;name__eq&#x3D;mymanifest&#x60;  **Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality by appending &#x60;__eq&#x60; to the field name * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;{field name}[|__eq|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering on multiple fields**  &#x60;name__eq&#x3D;mymanifest&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering with filter operators**  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__in&#x3D;fw-manifest1,fw-manifest2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public firmwareManifestList(
        limit?: number,
        order?: string,
        after?: string,
        filter?: string,
        include?: string,
        callback?: (error: any, data?: FirmwareManifestPage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<FirmwareManifestPage>(
            {
                url: "/v3/firmware-manifests/",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Get a manifest
     * Retrieve firmware manifest.
     * @param manifestId The firmware manifest ID
     */
    public firmwareManifestRetrieve(
        manifestId: string,
        callback?: (error: any, data?: FirmwareManifest, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "manifestId" is set
        if (manifestId === null || manifestId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'manifestId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<FirmwareManifest>(
            {
                url: "/v3/firmware-manifests/{manifest_id}/".replace("{" + "manifest_id" + "}", String(manifestId)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Create a campaign
     * Create an update campaign.
     * @param campaign Update campaign
     */
    public updateCampaignCreate(
        campaign: UpdateCampaignPostRequest,
        callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<UpdateCampaign>(
            {
                url: "/v3/update-campaigns/",
                method: "POST",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body: campaign,
            },
            callback
        );
    }
    /**
     * Delete a campaign
     * Delete an update campaign.
     * @param campaignId The ID of the update campaign
     */
    public updateCampaignDestroy(
        campaignId: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<null>(
            {
                url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * List all campaigns
     * Get update campaigns for devices specified by a filter.
     * @param limit How many update campaigns to retrieve
     * @param order The order of the records. Acceptable values: ASC, DESC. Default: ASC
     * @param after The ID of the the item after which to retrieve the next page
     * @param filter URL-encoded query string parameter to filter returned data  &#x60;?filter&#x3D;{URL-encoded query string}&#x60;   ###### Filterable fields:    The below table lists all the fields that can be filtered on with certain filters:    |       Field      | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte |   |:----------------:|:----------------:|:-------------:|:-------------:|   |    created_at    |         ✓        |       ✓       |       ✓       |   |    description   |         ✓        |       ✓       |               |   |   device_filter  |         ✓        |       ✓       |               |   |       etag       |         ✓        |       ✓       |       ✓       |   |     finished     |         ✓        |       ✓       |       ✓       |   |        id        |         ✓        |       ✓       |               |   |       name       |         ✓        |       ✓       |               |   | root_manifest_id |         ✓        |       ✓       |               |   |    started_at    |         ✓        |       ✓       |       ✓       |   |       state      |         ✓        |       ✓       |               |   |    updated_at    |         ✓        |       ✓       |       ✓       |   |       when       |         ✓        |       ✓       |       ✓       |  The query string is made up of key-value pairs separated by ampersands. For example, this query: &#x60;key1__eq&#x3D;value1&amp;key2__eq&#x3D;value2&amp;key3__eq&#x3D;value3&#x60;  would be URL-encoded as: &#x60;?filter&#x3D;key1__eq%3Dvalue1%26key2__eq%3Dvalue2%26key3__eq%3Dvalue3&#x60;   **Filtering by campaign properties** &#x60;state__eq&#x3D;[draft|scheduled|devicefectch|devicecopy|publishing|deploying|deployed|manifestremoved|expired]&#x60;  &#x60;root_manifest_id__eq&#x3D;43217771234242e594ddb433816c498a&#x60;  **Filtering on date-time fields**  Date-time fields should be specified in UTC RFC3339 format, &#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds. Example: &#x60;2016-11-30T16:25:12.1234Z&#x60; * UTC RFC3339 without milliseconds. Example: &#x60;2016-11-30T16:25:12Z&#x60; * UTC RFC3339 shortened without milliseconds and punctuation. Example: &#x60;20161130T162512Z&#x60;  Date-time filtering supports three operators:  * equality by appending &#x60;__eq&#x60; to the field name * greater than or equal to by appending &#x60;__gte&#x60; to the field name * less than or equal to by appending &#x60;__lte&#x60; to the field name  &#x60;{field name}[|__eq|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;  Time ranges may be specified by including both the &#x60;__gte&#x60; and &#x60;__lte&#x60; forms in the filter. For example:  &#x60;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering on multiple fields**  &#x60;state__eq&#x3D;deployed&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;  **Filtering with filter operators**  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__in&#x3D;fw-image1,fw-image2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public updateCampaignList(
        limit?: number,
        order?: string,
        after?: string,
        filter?: string,
        include?: string,
        callback?: (error: any, data?: UpdateCampaignPage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<UpdateCampaignPage>(
            {
                url: "/v3/update-campaigns/",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * List all campaign device metadata
     * Get campaign device metadata.
     * @param campaignId The update campaign ID
     * @param limit How many objects to retrieve in the page
     * @param order ASC or DESC
     * @param after The ID of the the item after which to retrieve the next page
     * @param include Comma-separated list of data fields to return. Currently supported: total_count
     */
    public updateCampaignMetadataList(
        campaignId: string,
        limit?: number,
        order?: string,
        after?: string,
        include?: string,
        callback?: (error: any, data?: CampaignDeviceMetadataPage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<CampaignDeviceMetadataPage>(
            {
                url: "/v3/update-campaigns/{campaign_id}/campaign-device-metadata/".replace(
                    "{" + "campaign_id" + "}",
                    String(campaignId)
                ),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Get a campaign device metadata
     * Get update campaign metadata.
     * @param campaignId The update campaign ID
     * @param campaignDeviceMetadataId The campaign device metadata ID
     */
    public updateCampaignMetadataRetrieve(
        campaignId: string,
        campaignDeviceMetadataId: string,
        callback?: (error: any, data?: CampaignDeviceMetadata, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaignDeviceMetadataId" is set
        if (campaignDeviceMetadataId === null || campaignDeviceMetadataId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignDeviceMetadataId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<CampaignDeviceMetadata>(
            {
                url: "/v3/update-campaigns/{campaign_id}/campaign-device-metadata/{campaign_device_metadata_id}/"
                    .replace("{" + "campaign_id" + "}", String(campaignId))
                    .replace("{" + "campaign_device_metadata_id" + "}", String(campaignDeviceMetadataId)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Stop a running campaign
     * Stop a running update campaign.
     * @param campaignId The campaign ID
     */
    public updateCampaignMetadataStop(
        campaignId: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<null>(
            {
                url: "/v3/update-campaigns/{campaign_id}/stop".replace("{" + "campaign_id" + "}", String(campaignId)),
                method: "POST",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Get a campaign.
     * Get an update campaign.
     * @param campaignId The campaign ID
     */
    public updateCampaignRetrieve(
        campaignId: string,
        callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<UpdateCampaign>(
            {
                url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Modify a campaign
     * Modify an update campaign.
     * @param campaignId
     * @param campaign Update campaign
     */
    public updateCampaignUpdate(
        campaignId: string,
        campaign: UpdateCampaignPutRequest,
        callback?: (error: any, data?: UpdateCampaign, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "campaignId" is set
        if (campaignId === null || campaignId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaignId' missing."));
            }
            return;
        }
        // verify required parameter "campaign" is set
        if (campaign === null || campaign === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'campaign' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<UpdateCampaign>(
            {
                url: "/v3/update-campaigns/{campaign_id}/".replace("{" + "campaign_id" + "}", String(campaignId)),
                method: "PUT",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body: campaign,
            },
            callback
        );
    }
}
