/* tslint:disable:array-type */
/* tslint:disable:no-namespace */
/* tslint:disable:no-string-literal */
/* tslint:disable:max-classes-per-file */
/* tslint:disable:no-trailing-whitespace */

// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================

/**
 * Device Directory API
 * This is the API Documentation for the Mbed Device Directory service.
 *
 * OpenAPI spec version: 3
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as superagent from "superagent";
import { ApiBase } from "../common/apiBase";
import { SDKError } from "../common/sdkError";

export namespace DeviceData {
    export type DeployedStateEnum = "development" | "production";
    export type MechanismEnum = "connector" | "direct";
    export type StateEnum = "unenrolled" | "cloud_enrolling" | "bootstrapped" | "registered" | "deregistered";
}
export interface DeviceData {
    /**
     * The ID of the associated account.
     */
    account_id?: string;
    /**
     * DEPRECATED: Mark this device for automatic firmware update.
     */
    auto_update?: boolean;
    /**
     * The expiration date of the certificate used to connect to bootstrap server.
     */
    bootstrap_expiration_date?: Date;
    /**
     * The timestamp of the device's most recent bootstrap process.
     */
    bootstrapped_timestamp?: Date;
    /**
     * The certificate issuer's ID.
     */
    ca_id?: string;
    /**
     * The expiration date of the certificate used to connect to LWM2M server.
     */
    connector_expiration_date?: Date;
    /**
     * The timestamp of when the device was created in the device directory.
     */
    created_at?: Date;
    /**
     * Up to five custom key-value attributes.
     */
    custom_attributes?: { [key: string]: string };
    /**
     * DEPRECATED: The state of the device's deployment.
     */
    deployed_state?: DeviceData.DeployedStateEnum;
    /**
     * DEPRECATED: The last deployment used on the device.
     */
    deployment?: string;
    /**
     * The description of the device.
     */
    description?: string;
    /**
     * An ID representing the model and hardware revision of the device.
     */
    device_class?: string;
    /**
     * The execution mode from the certificate of the device. Defaults to inheriting from host_gateway device. Permitted values:   - 0 - unspecified execution mode (default if host_gateway invalid or not set)   - 1 - development devices   - 5 - production devices
     */
    device_execution_mode?: number;
    /**
     * The fingerprint of the device certificate.
     */
    device_key?: string;
    /**
     * The endpoint name given to the device.
     */
    endpoint_name?: string;
    /**
     * The endpoint type of the device. For example, the device is a gateway.
     */
    endpoint_type?: string;
    /**
     * The claim date/time.
     */
    enrolment_list_timestamp?: Date;
    /**
     * The entity instance signature.
     */
    etag?: Date;
    /**
     * The SHA256 checksum of the current firmware image.
     */
    firmware_checksum?: string;
    /**
     * The `endpoint_name` of the host gateway, if appropriate.
     */
    host_gateway?: string;
    /**
     * The ID of the device. The device ID is used to manage a device across all Mbed Cloud APIs.
     */
    id?: string;
    /**
     * DEPRECATED: The URL for the current device manifest.
     */
    manifest?: string;
    /**
     * The timestamp of the current manifest version.
     */
    manifest_timestamp?: Date;
    /**
     * The ID of the channel used to communicate with the device.
     */
    mechanism?: DeviceData.MechanismEnum;
    /**
     * The address of the connector to use.
     */
    mechanism_url?: string;
    /**
     * The name of the device.
     */
    name?: string;
    /**
     * The API resource entity.
     */
    object?: string;
    /**
     * The serial number of the device.
     */
    serial_number?: string;
    /**
     * The current state of the device.
     */
    state?: DeviceData.StateEnum;
    /**
     * The time the object was updated.
     */
    updated_at?: Date;
    /**
     * The device vendor ID.
     */
    vendor_id?: string;
}

export interface DeviceDataPatchRequest {
    /**
     * DEPRECATED: Mark this device for automatic firmware update.
     */
    auto_update?: boolean;
    /**
     * The certificate issuer's ID.
     */
    ca_id?: string;
    /**
     * Up to five custom key-value attributes. Note that keys cannot start with a number.
     */
    custom_attributes?: { [key: string]: string };
    /**
     * The description of the device.
     */
    description?: string;
    /**
     * The fingerprint of the device certificate.
     */
    device_key?: string;
    /**
     * The endpoint name given to the device.
     */
    endpoint_name?: string;
    /**
     * The endpoint type of the device. For example, the device is a gateway.
     */
    endpoint_type?: string;
    /**
     * The `endpoint_name` of the host gateway, if appropriate.
     */
    host_gateway?: string;
    /**
     * The name of the device.
     */
    name?: string;
    /**
     * The API resource entity.
     */
    object?: string;
}

export namespace DeviceDataPostRequest {
    export type MechanismEnum = "connector" | "direct";
    export type StateEnum = "unenrolled" | "cloud_enrolling" | "bootstrapped" | "registered" | "deregistered";
}
export interface DeviceDataPostRequest {
    /**
     * DEPRECATED: Mark this device for automatic firmware update.
     */
    auto_update?: boolean;
    /**
     * The expiration date of the certificate used to connect to bootstrap server.
     */
    bootstrap_expiration_date?: Date;
    /**
     * The timestamp of the device's most recent bootstrap process.
     */
    bootstrapped_timestamp?: Date;
    /**
     * The certificate issuer's ID.
     */
    ca_id?: string;
    /**
     * The expiration date of the certificate used to connect to the LWM2M server.
     */
    connector_expiration_date?: Date;
    /**
     * Up to five custom key-value attributes. Note that keys cannot start with a number.
     */
    custom_attributes?: { [key: string]: string };
    /**
     * DEPRECATED: The last deployment used on the device.
     */
    deployment?: string;
    /**
     * The description of the device.
     */
    description?: string;
    /**
     * An ID representing the model and hardware revision of the device.
     */
    device_class?: string;
    /**
     * The execution mode from the certificate of the device. Permitted values:   - 0 - unspecified execution mode (default)   - 1 - development devices   - 5 - production devices
     */
    device_execution_mode?: number;
    /**
     * The fingerprint of the device certificate.
     */
    device_key?: string;
    /**
     * The endpoint name given to the device.
     */
    endpoint_name?: string;
    /**
     * The endpoint type of the device. For example, the device is a gateway.
     */
    endpoint_type?: string;
    /**
     * The SHA256 checksum of the current firmware image.
     */
    firmware_checksum?: string;
    /**
     * The `endpoint_name` of the host gateway, if appropriate.
     */
    host_gateway?: string;
    /**
     * DEPRECATED: The URL for the current device manifest.
     */
    manifest?: string;
    /**
     * The ID of the channel used to communicate with the device.
     */
    mechanism?: DeviceDataPostRequest.MechanismEnum;
    /**
     * The address of the connector to use.
     */
    mechanism_url?: string;
    /**
     * The name of the device.
     */
    name?: string;
    /**
     * The API resource entity.
     */
    object?: string;
    /**
     * The serial number of the device.
     */
    serial_number?: string;
    /**
     * The current state of the device.
     */
    state?: DeviceDataPostRequest.StateEnum;
    /**
     * The device vendor ID.
     */
    vendor_id?: string;
}

export interface DeviceDataPutRequest {
    /**
     * DEPRECATED: Mark this device for automatic firmware update.
     */
    auto_update?: boolean;
    /**
     * The certificate issuer's ID.
     */
    ca_id?: string;
    /**
     * Up to five custom key-value attributes. Note that keys cannot start with a number.
     */
    custom_attributes?: { [key: string]: string };
    /**
     * The description of the device.
     */
    description?: string;
    /**
     * The fingerprint of the device certificate.
     */
    device_key?: string;
    /**
     * The endpoint name given to the device.
     */
    endpoint_name?: string;
    /**
     * The endpoint type of the device. For example, the device is a gateway.
     */
    endpoint_type?: string;
    /**
     * The `endpoint_name` of the host gateway, if appropriate.
     */
    host_gateway?: string;
    /**
     * The name of the device.
     */
    name?: string;
    /**
     * The API resource entity.
     */
    object?: string;
}

export interface DeviceEqNeqFilter {
    account_id?: string;
    auto_update?: boolean;
    bootstrap_expiration_date?: Date;
    bootstrapped_timestamp?: Date;
    ca_id?: string;
    connector_expiration_date?: Date;
    created_at?: Date;
    custom_attributes?: { [key: string]: string };
    deployed_state?: string;
    deployment?: string;
    description?: string;
    device_class?: string;
    device_execution_mode?: number;
    device_key?: string;
    endpoint_name?: string;
    endpoint_type?: string;
    enrolment_list_timestamp?: Date;
    etag?: Date;
    firmware_checksum?: string;
    host_gateway?: string;
    id?: string;
    manifest?: string;
    manifest_timestamp?: Date;
    mechanism?: string;
    mechanism_url?: string;
    name?: string;
    serial_number?: string;
    state?: string;
    updated_at?: Date;
    vendor_id?: string;
}

export interface DeviceEventData {
    changes?: any;
    data?: any;
    date_time: Date;
    description?: string;
    device_id?: string;
    event_type?: string;
    event_type_description?: string;
    id: string;
    state_change?: boolean;
}

export interface DeviceEventEqNeqFilter {
    date_time?: Date;
    description?: string;
    device_id?: string;
    event_type?: string;
    id?: string;
    state_change?: boolean;
}

export interface DeviceEventGteLteFilter {
    date_time?: Date;
}

export interface DeviceEventInNinFilter {
    date_time?: Date;
    description?: string;
    device_id?: string;
    event_type?: string;
    id?: string;
    state_change?: boolean;
}

export interface DeviceEventPage {
    after?: string;
    data?: Array<DeviceEventData>;
    has_more?: boolean;
    limit?: number;
    object?: string;
    order?: string;
    total_count?: number;
}

export interface DeviceGteLteFilter {
    bootstrap_expiration_date?: Date;
    bootstrapped_timestamp?: Date;
    connector_expiration_date?: Date;
    created_at?: Date;
    enrolment_list_timestamp?: Date;
    etag?: Date;
    manifest_timestamp?: Date;
    updated_at?: Date;
}

export interface DeviceInNinFilter {
    account_id?: string;
    auto_update?: boolean;
    bootstrap_expiration_date?: Date;
    bootstrapped_timestamp?: Date;
    ca_id?: string;
    connector_expiration_date?: Date;
    created_at?: Date;
    custom_attributes?: { [key: string]: string };
    deployed_state?: string;
    deployment?: string;
    description?: string;
    device_class?: string;
    device_execution_mode?: number;
    device_key?: string;
    endpoint_name?: string;
    endpoint_type?: string;
    enrolment_list_timestamp?: Date;
    etag?: Date;
    firmware_checksum?: string;
    host_gateway?: string;
    id?: string;
    manifest?: string;
    manifest_timestamp?: Date;
    mechanism?: string;
    mechanism_url?: string;
    name?: string;
    serial_number?: string;
    state?: string;
    updated_at?: Date;
    vendor_id?: string;
}

export interface DevicePage {
    after?: string;
    data?: Array<DeviceData>;
    has_more?: boolean;
    limit?: number;
    object?: string;
    order?: string;
    total_count?: number;
}

export interface DeviceQuery {
    /**
     * The timestamp of when the device was created in the device directory.
     */
    created_at: Date;
    /**
     * The entity instance signature.
     */
    etag: Date;
    /**
     * The ID of the query.
     */
    id: string;
    /**
     * The name of the query.
     */
    name: string;
    /**
     * The API resource entity.
     */
    object: string;
    /**
     * The device query.
     */
    query: string;
    /**
     * The time the object was updated.
     */
    updated_at: Date;
}

export interface DeviceQueryEqNeqFilter {
    created_at?: Date;
    etag?: Date;
    id?: string;
    name?: string;
    query?: string;
    updated_at?: Date;
}

export interface DeviceQueryGteLteFilter {
    created_at?: Date;
    etag?: Date;
    updated_at?: Date;
}

export interface DeviceQueryInNinFilter {
    created_at?: Date;
    etag?: Date;
    id?: string;
    name?: string;
    query?: string;
    updated_at?: Date;
}

export interface DeviceQueryPage {
    after?: string;
    data: Array<DeviceQuery>;
    has_more: boolean;
    limit: number;
    object: string;
    order: string;
    total_count: number;
}

export interface DeviceQueryPatchRequest {
    /**
     * The name of the query.
     */
    name?: string;
    /**
     * The device query.
     */
    query?: string;
}

export interface DeviceQueryPostPutRequest {
    /**
     * The name of the query.
     */
    name: string;
    /**
     * The device query.
     */
    query: string;
}

/**
 * DefaultApi
 */
export class DefaultApi extends ApiBase {
    /**
     * Create a device
     * Create a new device.
     * @param device
     */
    public deviceCreate(
        device: DeviceDataPostRequest,
        callback?: (error: any, data?: DeviceData, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "device" is set
        if (device === null || device === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'device' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceData>(
            {
                url: "/v3/devices/",
                method: "POST",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body: device,
            },
            callback
        );
    }
    /**
     * Delete a device.
     * Delete device. Only available for devices with a developer certificate. Attempts to delete a device with a production certicate will return a 400 response.
     * @param id
     */
    public deviceDestroy(
        id: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "id" is set
        if (id === null || id === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'id' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<null>(
            {
                url: "/v3/devices/{id}/".replace("{" + "id" + "}", String(id)),
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * List all device events.
     * List all device events for an account.
     * @param limit How many objects to retrieve in the page.
     * @param order The order of the records based on creation time, &#x60;ASC&#x60; or &#x60;DESC&#x60;; by default &#x60;ASC&#x60;.
     * @param after The ID of The item after which to retrieve the next page.
     * @param filter URL encoded query string parameter to filter returned data.  ##### Filtering &#x60;&#x60;&#x60;?filter&#x3D;{URL encoded query string}&#x60;&#x60;&#x60;  The query string is made up of key/value pairs separated by ampersands. So for a query of &#x60;&#x60;&#x60;key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3&#x60;&#x60;&#x60; this would be encoded as follows: &#x60;&#x60;&#x60;?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3&#x60;&#x60;&#x60;  ###### Filterable fields:  The below table lists all the fields that can be filtered on with certain filters:  |     Field    | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:------------:|:----------------:|:-------------:|:-------------:| |   date_time  |         ✓        |       ✓       |       ✓       | |  description |         ✓        |       ✓       |               | |      id      |         ✓        |       ✓       |               | |   device_id  |         ✓        |       ✓       |               | |  event_type  |         ✓        |       ✓       |               | | state_change |         ✓        |       ✓       |               |  The examples below show the queries in *unencoded* form.  ###### By id: &#x60;&#x60;&#x60;id&#x3D;{id}&#x60;&#x60;&#x60;  ###### By state change: &#x60;&#x60;&#x60;state_change&#x3D;[True|False]&#x60;&#x60;&#x60;  ###### By event type: &#x60;&#x60;&#x60;event_type&#x3D;{value}&#x60;&#x60;&#x60;  ###### On date-time fields: Date-time fields should be specified in UTC RFC3339 format &#x60;&#x60;&#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;&#x60;&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds e.g. 2016-11-30T16:25:12.1234Z * UTC RFC3339 without milliseconds e.g. 2016-11-30T16:25:12Z * UTC RFC3339 shortened - without milliseconds and punctuation e.g. 20161130T162512Z  Date-time filtering supports three operators:  * equality * greater than or equal to &amp;ndash; field name suffixed with &#x60;&#x60;&#x60;__gte&#x60;&#x60;&#x60; * less than or equal to &amp;ndash; field name suffixed with &#x60;&#x60;&#x60;__lte&#x60;&#x60;&#x60;  Lower and upper limits to a date-time range may be specified by including both the &#x60;&#x60;&#x60;__gte&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;__lte&#x60;&#x60;&#x60; forms in the filter.  &#x60;&#x60;&#x60;{field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;&#x60;&#x60;  ##### Multi-field example  &#x60;&#x60;&#x60;id&#x3D;0158d38771f70000000000010010038c&amp;state_change&#x3D;True&amp;date_time__gte&#x3D;2016-11-30T16:25:12.1234Z&#x60;&#x60;&#x60;  Encoded:  &#x60;&#x60;&#x60;?filter&#x3D;id%3D0158d38771f70000000000010010038c%26state_change%3DTrue%26date_time__gte%3D2016-11-30T16%3A25%3A12.1234Z&#x60;&#x60;&#x60;  ##### Filtering with filter operators  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;event_type__in&#x3D;update.device.device-created,update.device.device-updated&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: &#x60;total_count&#x60;
     */
    public deviceEventList(
        limit?: number,
        order?: string,
        after?: string,
        filter?: string,
        include?: string,
        callback?: (error: any, data?: DeviceEventPage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceEventPage>(
            {
                url: "/v3/device-events/",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Retrieve a device event.
     * Retrieve a specific device event.
     * @param deviceEventId
     */
    public deviceEventRetrieve(
        deviceEventId: string,
        callback?: (error: any, data?: DeviceEventData, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceEventId" is set
        if (deviceEventId === null || deviceEventId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceEventId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceEventData>(
            {
                url: "/v3/device-events/{device_event_id}/".replace(
                    "{" + "device_event_id" + "}",
                    String(deviceEventId)
                ),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * List all devices.
     * List all devices.
     * @param limit How many objects to retrieve in the page.
     * @param order The order of the records based on creation time, &#x60;ASC&#x60; or &#x60;DESC&#x60;; by default &#x60;ASC&#x60;.
     * @param after The ID of The item after which to retrieve the next page.
     * @param filter URL encoded query string parameter to filter returned data.  ##### Filtering &#x60;&#x60;&#x60;?filter&#x3D;{URL encoded query string}&#x60;&#x60;&#x60;  The query string is made up of key/value pairs separated by ampersands. So for a query of &#x60;&#x60;&#x60;key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3&#x60;&#x60;&#x60; this would be encoded as follows: &#x60;&#x60;&#x60;?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3&#x60;&#x60;&#x60;  ###### Filterable fields:  The below table lists all the fields that can be filtered on with certain filters:  |           Field           | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:-------------------------:|:----------------:|:-------------:|:-------------:| |         account_id        |         ✓        |       ✓       |               | |        auto_update        |         ✓        |       ✓       |               | | bootstrap_expiration_date |         ✓        |       ✓       |       ✓       | |   bootstrapped_timestamp  |         ✓        |       ✓       |       ✓       | |           ca_id           |         ✓        |       ✓       |               | | connector_expiration_date |         ✓        |       ✓       |       ✓       | |         created_at        |         ✓        |       ✓       |       ✓       | |     custom_attributes     |         ✓        |               |               | |       deployed_state      |         ✓        |       ✓       |               | |         deployment        |         ✓        |       ✓       |               | |        description        |         ✓        |       ✓       |               | |        device_class       |         ✓        |       ✓       |               | |   device_execution_mode   |         ✓        |       ✓       |               | |         device_key        |         ✓        |       ✓       |               | |       endpoint_name       |         ✓        |       ✓       |               | |       endpoint_type       |         ✓        |       ✓       |               | |  enrolment_list_timestamp |         ✓        |       ✓       |       ✓       | |            etag           |         ✓        |       ✓       |       ✓       | |     firmware_checksum     |         ✓        |       ✓       |               | |        host_gateway       |         ✓        |       ✓       |               | |             id            |         ✓        |       ✓       |               | |          manifest         |         ✓        |       ✓       |               | |     manifest_timestamp    |         ✓        |       ✓       |       ✓       | |         mechanism         |         ✓        |       ✓       |               | |       mechanism_url       |         ✓        |       ✓       |               | |            name           |         ✓        |       ✓       |               | |       serial_number       |         ✓        |       ✓       |               | |           state           |         ✓        |       ✓       |               | |         updated_at        |         ✓        |       ✓       |       ✓       | |         vendor_id         |         ✓        |       ✓       |               |   The examples below show the queries in *unencoded* form.  ###### By device properties (all properties are filterable): &#x60;&#x60;&#x60;state&#x3D;[unenrolled|cloud_enrolling|bootstrapped|registered]&#x60;&#x60;&#x60;  &#x60;&#x60;&#x60;device_class&#x3D;{value}&#x60;&#x60;&#x60;  ###### On date-time fields: Date-time fields should be specified in UTC RFC3339 format &#x60;&#x60;&#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;&#x60;&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds e.g. 2016-11-30T16:25:12.1234Z * UTC RFC3339 without milliseconds e.g. 2016-11-30T16:25:12Z * UTC RFC3339 shortened - without milliseconds and punctuation e.g. 20161130T162512Z  Date-time filtering supports three operators:  * equality * greater than or equal to &amp;ndash; field name suffixed with &#x60;&#x60;&#x60;__gte&#x60;&#x60;&#x60; * less than or equal to &amp;ndash; field name suffixed with &#x60;&#x60;&#x60;__lte&#x60;&#x60;&#x60;  Lower and upper limits to a date-time range may be specified by including both the &#x60;&#x60;&#x60;__gte&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;__lte&#x60;&#x60;&#x60; forms in the filter.  &#x60;&#x60;&#x60;{field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;&#x60;&#x60;  ###### On device custom attributes:  &#x60;&#x60;&#x60;custom_attributes__{param}&#x3D;{value}&#x60;&#x60;&#x60; &#x60;&#x60;&#x60;custom_attributes__tag&#x3D;TAG1&#x60;&#x60;&#x60;  ##### Multi-field example  &#x60;&#x60;&#x60;state&#x3D;bootstrapped&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;&#x60;&#x60;  Encoded:  &#x60;&#x60;&#x60;?filter&#x3D;state%3Dbootstrapped%26created_at__gte%3D2016-11-30T16%3A25%3A12.1234Z%26created_at__lte%3D2016-11-30T00%3A00%3A00Z&#x60;&#x60;&#x60;  ##### Filtering with filter operators  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;state__nin&#x3D;unenrolled,dergistered&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: &#x60;total_count&#x60;.
     */
    public deviceList(
        limit?: number,
        order?: string,
        after?: string,
        filter?: string,
        include?: string,
        callback?: (error: any, data?: DevicePage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DevicePage>(
            {
                url: "/v3/devices/",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * DEPRECATED: List all device events.
     * DEPRECATED: List all device events. Use &#x60;/v3/device-events/&#x60; instead.
     * @param limit How many objects to retrieve in the page.
     * @param order The order of the records based on creation time, &#x60;ASC&#x60; or &#x60;DESC&#x60;; by default &#x60;ASC&#x60;.
     * @param after The ID of The item after which to retrieve the next page.
     * @param filter URL encoded query string parameter to filter returned data.  ##### Filtering &#x60;&#x60;&#x60;?filter&#x3D;{URL encoded query string}&#x60;&#x60;&#x60;  The query string is made up of key/value pairs separated by ampersands. So for a query of &#x60;&#x60;&#x60;key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3&#x60;&#x60;&#x60; this would be encoded as follows: &#x60;&#x60;&#x60;?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3&#x60;&#x60;&#x60;  ###### Filterable fields:  The below table lists all the fields that can be filtered on with certain filters:  |     Field    | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:------------:|:----------------:|:-------------:|:-------------:| |   date_time  |         ✓        |       ✓       |       ✓       | |  description |         ✓        |       ✓       |               | |      id      |         ✓        |       ✓       |               | |   device_id  |         ✓        |       ✓       |               | |  event_type  |         ✓        |       ✓       |               | | state_change |         ✓        |       ✓       |               |  The examples below show the queries in *unencoded* form.  ###### By id: &#x60;&#x60;&#x60;id&#x3D;{id}&#x60;&#x60;&#x60;  ###### By state change: &#x60;&#x60;&#x60;state_change&#x3D;[True|False]&#x60;&#x60;&#x60;  ###### By event type: &#x60;&#x60;&#x60;event_type&#x3D;{value}&#x60;&#x60;&#x60;  ###### On date-time fields: Date-time fields should be specified in UTC RFC3339 format &#x60;&#x60;&#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;&#x60;&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds e.g. 2016-11-30T16:25:12.1234Z * UTC RFC3339 without milliseconds e.g. 2016-11-30T16:25:12Z * UTC RFC3339 shortened - without milliseconds and punctuation e.g. 20161130T162512Z  Date-time filtering supports three operators:  * equality * greater than or equal to &amp;ndash; field name suffixed with &#x60;&#x60;&#x60;__gte&#x60;&#x60;&#x60; * less than or equal to &amp;ndash; field name suffixed with &#x60;&#x60;&#x60;__lte&#x60;&#x60;&#x60;  Lower and upper limits to a date-time range may be specified by including both the &#x60;&#x60;&#x60;__gte&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;__lte&#x60;&#x60;&#x60; forms in the filter.  &#x60;&#x60;&#x60;{field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;&#x60;&#x60;  ##### Multi-field example  &#x60;&#x60;&#x60;id&#x3D;0158d38771f70000000000010010038c&amp;state_change&#x3D;True&amp;date_time__gte&#x3D;2016-11-30T16:25:12.1234Z&#x60;&#x60;&#x60;  Encoded:  &#x60;&#x60;&#x60;?filter&#x3D;id%3D0158d38771f70000000000010010038c%26state_change%3DTrue%26date_time__gte%3D2016-11-30T16%3A25%3A12.1234Z&#x60;&#x60;&#x60;  ##### Filtering with filter operators  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;event_type__in&#x3D;update.device.device-created,update.device.device-updated&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: &#x60;total_count&#x60;.
     */
    public deviceLogList(
        limit?: number,
        order?: string,
        after?: string,
        filter?: string,
        include?: string,
        callback?: (error: any, data?: DeviceEventPage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceEventPage>(
            {
                url: "/v3/devicelog/",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * DEPRECATED: Retrieve a device event.
     * Retrieve device event (deprecated, use /v3/device-events/{device_event_id}/ instead)
     * @param deviceEventId
     */
    public deviceLogRetrieve(
        deviceEventId: string,
        callback?: (error: any, data?: DeviceEventData, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceEventId" is set
        if (deviceEventId === null || deviceEventId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceEventId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceEventData>(
            {
                url: "/v3/devicelog/{device_event_id}/".replace("{" + "device_event_id" + "}", String(deviceEventId)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Create a device query
     * Create a new device query.
     * @param device
     */
    public deviceQueryCreate(
        device: DeviceQueryPostPutRequest,
        callback?: (error: any, data?: DeviceQuery, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "device" is set
        if (device === null || device === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'device' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceQuery>(
            {
                url: "/v3/device-queries/",
                method: "POST",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body: device,
            },
            callback
        );
    }
    /**
     * Delete a device query
     * Delete a device query.
     * @param queryId
     */
    public deviceQueryDestroy(
        queryId: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "queryId" is set
        if (queryId === null || queryId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'queryId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<null>(
            {
                url: "/v3/device-queries/{query_id}/".replace("{" + "query_id" + "}", String(queryId)),
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * List device queries.
     * List all device queries. The result will be paged into pages of 100.
     * @param limit How many objects to retrieve in the page.
     * @param order The order of the records based on creation time, &#x60;ASC&#x60; or &#x60;DESC&#x60;; by default &#x60;ASC&#x60;.
     * @param after The ID of The item after which to retrieve the next page.
     * @param filter URL encoded query string parameter to filter returned data.  ##### Filtering &#x60;&#x60;&#x60;?filter&#x3D;{URL encoded query string}&#x60;&#x60;&#x60;  The query string is made up of key/value pairs separated by ampersands. So for a query of &#x60;&#x60;&#x60;key1&#x3D;value1&amp;key2&#x3D;value2&amp;key3&#x3D;value3&#x60;&#x60;&#x60; this would be encoded as follows: &#x60;&#x60;&#x60;?filter&#x3D;key1%3Dvalue1%26key2%3Dvalue2%26key3%3Dvalue3&#x60;&#x60;&#x60;  The below table lists all the fields that can be filtered on with certain filters:  |    Field   | &#x3D; / __eq / __neq | __in /  __nin | __lte / __gte | |:----------:|:----------------:|:-------------:|:-------------:| | created_at |         ✓        |       ✓       |       ✓       | |    etag    |         ✓        |       ✓       |       ✓       | |     id     |         ✓        |       ✓       |               | |    name    |         ✓        |       ✓       |               | |    query   |         ✓        |       ✓       |               | | updated_at |         ✓        |       ✓       |       ✓       |   The examples below show the queries in *unencoded* form.  ###### By device query properties (all properties are filterable): For example: &#x60;&#x60;&#x60;description&#x3D;{value}&#x60;&#x60;&#x60;  ###### On date-time fields: Date-time fields should be specified in UTC RFC3339 format &#x60;&#x60;&#x60;YYYY-MM-DDThh:mm:ss.msZ&#x60;&#x60;&#x60;. There are three permitted variations:  * UTC RFC3339 with milliseconds e.g. 2016-11-30T16:25:12.1234Z * UTC RFC3339 without milliseconds e.g. 2016-11-30T16:25:12Z * UTC RFC3339 shortened - without milliseconds and punctuation e.g. 20161130T162512Z  Date-time filtering supports three operators:  * equality * greater than or equal to &amp;ndash; field name suffixed with &#x60;&#x60;&#x60;__gte&#x60;&#x60;&#x60; * less than or equal to &amp;ndash; field name suffixed with &#x60;&#x60;&#x60;__lte&#x60;&#x60;&#x60;  Lower and upper limits to a date-time range may be specified by including both the &#x60;&#x60;&#x60;__gte&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;__lte&#x60;&#x60;&#x60; forms in the filter.  &#x60;&#x60;&#x60;{field name}[|__lte|__gte]&#x3D;{UTC RFC3339 date-time}&#x60;&#x60;&#x60;  ##### Multi-field example  &#x60;&#x60;&#x60;query_id&#x3D;0158d38771f70000000000010010038c&amp;created_at__gte&#x3D;2016-11-30T16:25:12.1234Z&amp;created_at__lte&#x3D;2016-12-30T00:00:00Z&#x60;&#x60;&#x60;  Encoded:  &#x60;&#x60;&#x60;filter&#x3D;query_id%3D0158d38771f70000000000010010038c%26created_at__gte%3D2016-11-30T16%3A25%3A12.1234Z%26created_at__lte%3D2016-11-30T00%3A00%3A00Z&#x60;&#x60;&#x60;  ##### Filtering with filter operators  String field filtering supports the following operators:  * equality: &#x60;__eq&#x60; * non-equality: &#x60;__neq&#x60; * in : &#x60;__in&#x60; * not in: &#x60;__nin&#x60;  For &#x60;__in&#x60; and &#x60;__nin&#x60; filters list of parameters must be comma-separated:  &#x60;name__nin&#x3D;query1,query2&#x60;
     * @param include Comma-separated list of data fields to return. Currently supported: &#x60;total_count&#x60;.
     */
    public deviceQueryList(
        limit?: number,
        order?: string,
        after?: string,
        filter?: string,
        include?: string,
        callback?: (error: any, data?: DeviceQueryPage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};
        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }
        if (order !== undefined) {
            queryParameters["order"] = order;
        }
        if (after !== undefined) {
            queryParameters["after"] = after;
        }
        if (filter !== undefined) {
            queryParameters["filter"] = filter;
        }
        if (include !== undefined) {
            queryParameters["include"] = include;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceQueryPage>(
            {
                url: "/v3/device-queries/",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Retrieve a device query.
     * Retrieve a specific device query.
     * @param queryId
     */
    public deviceQueryRetrieve(
        queryId: string,
        callback?: (error: any, data?: DeviceQuery, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "queryId" is set
        if (queryId === null || queryId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'queryId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceQuery>(
            {
                url: "/v3/device-queries/{query_id}/".replace("{" + "query_id" + "}", String(queryId)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Update a device query
     * Update a specifc device query.
     * @param queryId
     * @param body Device query update object.
     */
    public deviceQueryUpdate(
        queryId: string,
        body: DeviceQueryPostPutRequest,
        callback?: (error: any, data?: DeviceQuery, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "queryId" is set
        if (queryId === null || queryId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'queryId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceQuery>(
            {
                url: "/v3/device-queries/{query_id}/".replace("{" + "query_id" + "}", String(queryId)),
                method: "PUT",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body,
            },
            callback
        );
    }
    /**
     * Get a devices
     * Retrieve information about a specific device.
     * @param id
     */
    public deviceRetrieve(
        id: string,
        callback?: (error: any, data?: DeviceData, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "id" is set
        if (id === null || id === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'id' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceData>(
            {
                url: "/v3/devices/{id}/".replace("{" + "id" + "}", String(id)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Update a device
     * Update a specific device.
     * @param id The ID of the device.
     * @param device
     */
    public deviceUpdate(
        id: string,
        device: DeviceDataPutRequest,
        callback?: (error: any, data?: DeviceData, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "id" is set
        if (id === null || id === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'id' missing."));
            }
            return;
        }
        // verify required parameter "device" is set
        if (device === null || device === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'device' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<DeviceData>(
            {
                url: "/v3/devices/{id}/".replace("{" + "id" + "}", String(id)),
                method: "PUT",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body: device,
            },
            callback
        );
    }
}
