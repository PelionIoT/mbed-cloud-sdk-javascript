/* tslint:disable:array-type */
/* tslint:disable:no-namespace */
/* tslint:disable:no-string-literal */
/* tslint:disable:max-classes-per-file */
/* tslint:disable:no-trailing-whitespace */

// ===============================================
// This file is autogenerated - Please do not edit
// Tracks base typescript-fetch mustache 01/02/17
// ===============================================

/**
 * Connect API
 * Pelion Device Management Connect API allows web applications to communicate with devices. You can subscribe to device resources and read/write values to them. Device Management Connect allows connectivity to devices by queueing requests and caching resource values.
 *
 * OpenAPI spec version: 2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as superagent from "superagent";
import { ApiBase } from "../common/apiBase";
import { SDKError } from "../common/sdkError";

export interface AsyncID {
    /**
     * Asynchronous response unique ID.
     */
    "async-response-id"?: string;
}

export interface AsyncIDResponse {
    /**
     * The content type.
     */
    ct?: string;
    /**
     * An optional error message describing the error.
     */
    error?: string;
    /**
     * The unique ID of the asynchronous response.
     */
    id?: string;
    /**
     * Determines how long this value stays valid in the cache, in seconds. 0 means that the value is not stored in the cache.
     */
    "max-age"?: string;
    /**
     * Requested data, base64 encoded.
     */
    payload?: string;
    /**
     * The asynchronous response status code for a device operation related to a proxy request or manual subscription.
     */
    status?: number;
}

export interface DeviceRequest {
    /**
     * The content type of an accepted response.
     */
    accept?: string;
    /**
     * The content type of the payload.
     */
    "content-type"?: string;
    /**
     * The CoAP request method. Allowed values are GET, POST, PUT and DELETE.
     */
    method: string;
    /**
     * The base64 encoded payload to be sent to the device.
     */
    "payload-b64"?: string;
    /**
     * The URI path of the requested resource.
     */
    uri: string;
}

export interface Endpoint {
    /**
     * Unique Device Management Device ID representing the endpoint.
     */
    name?: string;
    /**
     * Determines whether the device is in queue mode. <br/><br/><b>Queue mode</b><br/> When an endpoint is in queue mode, messages sent to the endpoint do not wake up the physical device. The messages are queued and delivered when the device wakes up and connects to Device Management Connect itself. You can also use the queue mode when the device is behind a NAT and cannot be reached directly by Device Management Connect.
     */
    q?: boolean;
    /**
     * Deprecated and the value is always ACTIVE. Only used for API backwards compatibility reasons.
     */
    status?: string;
    /**
     * Type of endpoint. (Free text)
     */
    type?: string;
}

export interface EndpointData {
    /**
     * Unique Device Management device ID.
     */
    ep?: string;
    /**
     * Endpoint type.
     */
    ept?: string;
    /**
     * In case of a self-provided endpoint name that is used to initiate the device registration, Device Management provides a new device ID to be used from that point on. The new Pelion platform provided Device ID is forwarded as the 'ep' property and the original self-provided one as the optional 'original-ep' property in a registration notification. The name and ID can then be mapped accordingly. Device Management saves the original endpoint name in the Device Directory for future device registrations so that you don't need to do the mapping again.
     */
    "original-ep"?: string;
    /**
     * Queue mode (default value is false).
     */
    q?: boolean;
    resources?: Array<ResourcesData>;
}

export interface NotificationData {
    /**
     * Content type.
     */
    ct?: string;
    /**
     * Device Management Device ID.
     */
    ep?: string;
    /**
     * Max age value is an integer number of seconds between 0 and 2^32-1 but the actual maximum cache time is limited to 3 days. A default value of 60 seconds is assumed in the absence of the option.
     */
    "max-age"?: string;
    /**
     * URI path.
     */
    path?: string;
    /**
     * Base64 encoded payload.
     */
    payload?: string;
}

export interface NotificationMessage {
    "async-responses"?: Array<AsyncIDResponse>;
    "de-registrations"?: Array<string>;
    notifications?: Array<NotificationData>;
    "reg-updates"?: Array<EndpointData>;
    registrations?: Array<EndpointData>;
    "registrations-expired"?: Array<string>;
}

export interface Presubscription {
    /**
     * The device ID.
     */
    "endpoint-name"?: string;
    "endpoint-type"?: string;
    "resource-path"?: Array<string>;
}

export interface PresubscriptionArray extends Array<Presubscription> {}

export interface Resource {
    /**
     * Observable determines whether you can subscribe to changes for this resource. It can have values \"true\" or \"false\".
     */
    obs?: boolean;
    /**
     * Application specific resource type that describes this resource. [It is created by the client side application](/docs/current/connecting/resource-setup-in-device-management-client.html). Not meant to be a human-readable name for the resource. Multiple resource types may be included, they are separated by a space.
     */
    rt?: string;
    /**
     * The content type of the resource. <br/><br/><b>Important</b><br/> You are encouraged to use the resource types listed in the [LwM2M specification](http://technical.openmobilealliance.org/Technical/technical-information/omna/lightweight-m2m-lwm2m-object-registry).
     */
    type?: string;
    /**
     * The URL of the resource.
     */
    uri: string;
}

/**
 * A resource URI
 */
export interface ResourcePath {}

export interface ResourcesData {
    /**
     * Content type.
     */
    ct?: string;
    /**
     * Interface description that defines a name or URI that indicates how to interact with the target resource. It describes a generic interface type, such as a \"sensor\".
     */
    if?: string;
    /**
     * Whether the resource is observable or not (true/false).
     */
    obs?: boolean;
    /**
     * Resource's URI path.
     */
    path?: string;
    /**
     * Application-specific resource type that describes this resource. [It is created by the client side application](/docs/current/connecting/resource-setup-in-device-management-client.html). Not meant to be a human-readable name for the resource. Multiple resource types may be included, they are separated by a space.
     */
    rt?: string;
}

/**
 * A list of resource URIs, one per line
 */
export interface SubscriptionsList {}

export interface Webhook {
    /**
     * The headers (key/value) sent with the notification. Optional.
     */
    headers?: { [key: string]: string };
    /**
     * The URL to which the notifications are sent. We recommend that you serve this URL over HTTPS.
     */
    url: string;
}

export namespace WebsocketChannel {
    export type StatusEnum = "connected" | "disconnected";
}
export interface WebsocketChannel {
    /**
     * Unique identifier of the channel
     */
    channelId?: string;
    /**
     * Number of events in the channel's event queue waiting to be delivered.
     */
    queueSize?: number;
    /**
     * Channel status will be 'connected' when the channel has an active WebSocket bound to it. The state will be 'disconnected' when either the channel or the WebSocket bound to it is closed.
     */
    status?: WebsocketChannel.StatusEnum;
}

/**
 * DeviceRequestsApi
 */
export class DeviceRequestsApi extends ApiBase {
    /**
     * Send an async request to device
     * This API provides an interface to asynchronously call methods on a device.  The &#x60;async-id&#x60; is provided by the client, enabling the client to track the end-to-end flow with an identifier that is relevant to the end application. For example, a web application&#39;s session ID along with the device ID and the resource path could be used as the &#x60;async-id&#x60;. This also avoids any race conditions with [the notification channel](/docs/current/integrate-web-app/event-notification.html). All responses are sent through the currently configured notification channel as an **AsyncIDResponse**.  For &#x60;GET&#x60; methods, values may be fetched from an internal cache, instead of contacting the device.  See also /v2/endpoints/{device-id}/{resourcePath}.  &#x60;&#x60;&#x60; Example URI: POST /v2/device-requests/015f2fa34d310000000000010030036c?async-id&#x3D;123e4567-e89b-12d3-a456-426655440000  Example payloads: { \&quot;method\&quot;: \&quot;GET\&quot;, \&quot;uri\&quot;: \&quot;/5/0/1\&quot; } { \&quot;method\&quot;: \&quot;PUT\&quot;, \&quot;uri\&quot;: \&quot;/5/0/1%20?k1&#x3D;v1&amp;k2&#x3D;v2%22\&quot;, \&quot;accept\&quot;: \&quot;text/plain\&quot;, \&quot;content-type\&quot;: \&quot;text/plain\&quot;, \&quot;payload-b64\&quot;: \&quot;dmFsdWUxCg&#x3D;&#x3D;\&quot; }  Immediate response: 202 Accepted  Example AsyncIDResponse, delivered via the notification channel: { \&quot;async-responses\&quot;: [ { \&quot;id\&quot;: \&quot;123e4567-e89b-12d3-a456-426655440000\&quot;, \&quot;status\&quot;: 200, \&quot;payload\&quot;: \&quot;dmFsdWUxCg&#x3D;&#x3D;\&quot;, \&quot;ct\&quot;: \&quot;text/plain\&quot;, \&quot;max-age\&quot;: 600 } ] } &#x60;&#x60;&#x60;
     * @param deviceId The device ID generated by Device Management.
     * @param asyncId The client-generated ID for matching the correct response delivered via a notification.
     * @param body Device request to send.
     */
    public createAsyncRequest(
        deviceId: string,
        asyncId: string,
        body: DeviceRequest,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }
        // verify required parameter "asyncId" is set
        if (asyncId === null || asyncId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'asyncId' missing."));
            }
            return;
        }
        // verify required parameter "body" is set
        if (body === null || body === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'body' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (asyncId !== undefined) {
            queryParameters["async-id"] = asyncId;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = ["application/json"];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<null>(
            {
                url: "/v2/device-requests/{device-id}".replace("{" + "device-id" + "}", String(deviceId)),
                method: "POST",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body,
            },
            callback
        );
    }
}
/**
 * EndpointsApi
 */
export class EndpointsApi extends ApiBase {
    /**
     * (DEPRECATED) List registered endpoints. The number of returned endpoints is currently limited to 200.
     * Endpoints are physical devices having valid registration to Device Management. All devices regardless of registration status can be requested from Device Directory API [&#39;/v3/devices/&#x60;](/docs/current/service-api-references/device-directory.html).  **Note:** This endpoint is deprecated and will be removed 1Q/18. You should use the Device Directory API [&#x60;/v3/devices/&#x60;](/docs/current/service-api-references/device-directory.html). To list only the registered devices, use filter &#x60;/v3/devices/?filter&#x3D;state%3Dregistered&#x60;.  **Example usage:**      curl -X GET https://api.us-east-1.mbedcloud.com/v2/endpoints -H &#39;authorization: Bearer {api-key}&#39;
     * @param type Filter endpoints by endpoint-type.
     */
    public getConnectedEndpoints(
        type?: string,
        callback?: (error: any, data?: Array<Endpoint>, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};
        if (type !== undefined) {
            queryParameters["type"] = type;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<Array<Endpoint>>(
            {
                url: "/v2/endpoints",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * List the resources on an endpoint
     * The list of resources is cached by Device Management Connect, so this call does not create a message to the device.  **Example usage:**      curl -X GET https://api.us-east-1.mbedcloud.com/v2/endpoints/{device-id} -H &#39;authorization: Bearer {api-key}&#39;
     * @param deviceId A unique device ID for an endpoint. Note that the ID needs to be an exact match. You cannot use wildcards here.
     */
    public getEndpointResources(
        deviceId: string,
        callback?: (error: any, data?: Array<Resource>, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<Array<Resource>>(
            {
                url: "/v2/endpoints/{device-id}".replace("{" + "device-id" + "}", String(deviceId)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
}
/**
 * NotificationsApi
 */
export class NotificationsApi extends ApiBase {
    /**
     * Open the websocket.
     *  A websocket channel can have only one active websocket connection at a time. If a websocket connection for a channel exists and a new connection to the same channel is made the connection is accepted and the older connection will be closed.&lt;br/&gt; Once the socket has been opened, it may be closed with one of the following status codes&lt;br/&gt; **1000**: Socket closed by the client. **1001**: Going away. set when another socket was opened on the used channel, or if the channel was deleted with a REST call, or if the server is shutting down. **1006**: Abnormal loss of connection. This code is never set by the service. **1008**: Policy violation. Set when the API key is missing or invalid. **1011**: Unexpected condition. Socket will be closed with this status at an attempt to open a socket to an unexisting channel (without a prior REST PUT). This code is also used to indicate closing socket for any other unexpected condition in the server.
     * @param connection
     * @param upgrade
     * @param secWebSocketProtocol ApiKey must be present in the &#x60;Sec-WebSocket-Protocol&#x60; header &#x60;\&quot;Sec-WebSocket-Protocol\&quot;:\&quot;wss,pelion_ak_{api_key}\&quot;&#x60; Refer to the notification service documentation for examples of usage.
     */
    public connectWebsocket(
        connection: string,
        upgrade: string,
        secWebSocketProtocol: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "connection" is set
        if (connection === null || connection === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'connection' missing."));
            }
            return;
        }
        // verify required parameter "upgrade" is set
        if (upgrade === null || upgrade === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'upgrade' missing."));
            }
            return;
        }
        // verify required parameter "secWebSocketProtocol" is set
        if (secWebSocketProtocol === null || secWebSocketProtocol === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'secWebSocketProtocol' missing."));
            }
            return;
        }

        const headerParams: any = {};
        if (connection !== undefined) {
            headerParams["Connection"] = connection;
        }
        if (upgrade !== undefined) {
            headerParams["Upgrade"] = upgrade;
        }
        if (secWebSocketProtocol !== undefined) {
            headerParams["Sec-WebSocket-Protocol"] = secWebSocketProtocol;
        }

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/notification/websocket-connect",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Delete notification Long Poll channel
     * To delete a notification Long Poll channel. This is required to change the channel from Long Poll to another type. You should not make a GET &#x60;/v2/notification/pull&#x60; call for 2 minutes after channel was deleted, because it can implicitly recreate the pull channel. You can also have some random responses with payload or 410 GONE with \&quot;CHANNEL_DELETED\&quot; as a payload or 200/204 until the old channel is purged.  **Example usage:**     curl -X DELETE https://api.us-east-1.mbedcloud.com/v2/notification/pull -H &#39;authorization: Bearer {api-key}&#39;
     */
    public deleteLongPollChannel(
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/notification/pull",
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Delete websocket channel.
     * To delete a notification websocket channel bound to the API key. This is required to change the channel from websocket to another type.  **Example usage:**      curl -X DELETE https://api.us-east-1.mbedcloud.com/v2/notification/websocket -H &#39;authorization: Bearer {api-key}&#39;
     */
    public deleteWebsocket(
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/notification/websocket",
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Delete callback URL
     * Deletes the callback URL.  **Example usage:**      curl -X DELETE https://api.us-east-1.mbedcloud.com/v2/notification/callback -H &#39;authorization: Bearer {api-key}&#39;
     */
    public deregisterWebhook(
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/notification/callback",
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Check callback URL
     * Shows the current callback URL if it exists.  **Example usage:**      curl -X GET https://api.us-east-1.mbedcloud.com/v2/notification/callback -H &#39;authorization: Bearer {api-key}&#39;
     */
    public getWebhook(
        callback?: (error: any, data?: Webhook, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<Webhook>(
            {
                url: "/v2/notification/callback",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Get websocket channel information.
     * Returns 200 with websocket connection status if websocket channel exists.  **Example usage:**      curl -X GET https://api.us-east-1.mbedcloud.com/v2/notification/websocket -H &#39;authorization: Bearer {api-key}&#39;
     */
    public getWebsocket(
        callback?: (error: any, data?: WebsocketChannel, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<WebsocketChannel>(
            {
                url: "/v2/notification/websocket",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Get notifications using Long Poll
     * In this case, notifications are delivered through HTTP long poll requests. The HTTP request is kept open until an event notification or a batch of event notifications are delivered to the client or the request times out (response code 204). In both cases, the client should open a new polling connection after the previous one closes. Only a single long polling connection per API key can be ongoing at any given time. You must have a persistent connection (Connection keep-alive header in the request) to avoid excess TLS handshakes.  The pull channel is implicitly created by the first GET call to &#x60;/v2/notification/pull&#x60;. It is refreshed on each GET call. If the channel is not polled for a long time (10 minutes) - it expires and will be deleted. This means that no notifications will stay in the queue between polls. A channel can be also deleted explicitly by a DELETE call.  **Note:** If you cannot have a public facing callback URL, for example when developing on your local machine, you can use long polling to check for new messages. However, **long polling is deprecated** and will likely be replaced in future. It is meant only for experimentation and not for commercial usage. The proper method to receive notifications is a **notification callback**. There can only be one notification channel per API key at a time in Device Management Connect. If a notification channel of other type already exists for the API key, you need to delete it before creating a long poll notification channel.  **Example usage:**      curl -X GET https://api.us-east-1.mbedcloud.com/v2/notification/pull -H &#39;authorization: Bearer {api-key}&#39;
     */
    public longPollNotifications(
        callback?: (error: any, data?: NotificationMessage, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<NotificationMessage>(
            {
                url: "/v2/notification/pull",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Register a callback URL
     * Register a URL to which the server should deliver notifications of the subscribed resource changes. To get notifications pushed, you also need to place the subscriptions. The maximum length of the URL, header keys and values, all combined, is 400 characters. Notifications are delivered as PUT messages to the HTTP server defined by the client with a subscription server message. The given URL should be accessible and respond to the PUT request with response code of 200 or 204. Device Management Connect tests the callback URL with an empty payload when the URL is registered. For more information on notification messages, see [NotificationMessage](#NotificationMessage).  **Optional headers in a callback message:**  You can set optional headers to a callback in a **Webhook** object. Device Management Connect will include the header and key pairs to the notification messages send them to callback URL. As the callback URL&#39;s are API key specific also the headers are.  One possible use for the additional headers is to check the origin of a PUT request and also distinguish the application (API key) to which the notification belongs to.  **Note**: Only one callback URL per an API key can be active. If you register a new URL while another one is already active, it replaces the active one. There can be only one notification channel at a time. If another type of channel is already present, you need to delete it before setting the callback URL.  **Expiration of a callback URL:**  A callback can expire when Device Management cannot deliver a notification due to a connection timeout or an error response (4xx or 5xx). After each delivery failure, Device Management sets an exponential back off time and makes a retry attempt after that. The first retry delay is 1 second, then 2s, 4s, 8s, ..., 2min, 2min. The maximum retry delay is 2 minutes. The callback URL will be removed if all retries fail within 24 hours. More about [notification sending logic](/docs/current/integrate-web-app/event-notification.html#notification-sending-logic).  **Supported callback URL protocols:**  Currently, only HTTP and HTTPS protocols are supported.  **HTTPS callback URLs:**  When delivering a notification to an HTTPS based callback URL, Device Management Connect will present a valid client certificate to identify itself. The certificate is signed by a trusted certificate authorithy (GlobalSign) with a Common Name (CN) set to notifications.mbedcloud.com.  **Example usage:**  This example command shows how to set your callback URL and API key. It also sets an optional header authorization. When Device Management Connect calls your callback URL, the call contains the authorization header with the defined value.      curl -X PUT \\       https://api.us-east-1.mbedcloud.com/v2/notification/callback \\       -H &#39;authorization: Bearer {api-key}&#39; \\       -H &#39;content-type: application/json&#39; \\       -d &#39;{       \&quot;url\&quot;: \&quot;{callback-url}\&quot;,       \&quot;headers\&quot;: {\&quot;authorization\&quot; : \&quot;f4b93d6e-4652-4874-82e4-41a3ced0cd56\&quot;}       }&#39;
     * @param webhook A json object that contains the optional headers and the URL to which the notifications need to be sent.
     */
    public registerWebhook(
        webhook: Webhook,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "webhook" is set
        if (webhook === null || webhook === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'webhook' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = ["application/json"];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/notification/callback",
                method: "PUT",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body: webhook,
            },
            callback
        );
    }
    /**
     * Register a websocket channel
     * Register (or update) a channel which will use websocket connection to deliver notifications. The websocket channel should be opened by client using &#x60;/v2/notification/websocket-connect&#x60; endpoint. To get notifications pushed, you also need to place the subscriptions. For more information on notification messages, see [NotificationMessage](#NotificationMessage).  A websocket channel can have only one active websocket connection at a time. If a websocket connection for a channel exists and a new connection to the same channel is made the connection is accepted and the older connection will be closed.  **Expiration of a websocket:**  A websocket channel will be expired if the channel does not have an opened websocket connection for 24 hour period. Channel expiration means the channel will be deleted and any undelivered notifications stored in its internal queue will be removed. As long as the channel has an opened websocket connection or time between successive websocket connections is less than 24 hours, the channel is considered active, notifications are stored in its internal queue and delivered when a websocket connection is active. A channel can be also deleted explicitly by a DELETE call.  More about [notification sending logic](/docs/current/integrate-web-app/event-notification.html#notification-sending-logic).  **Example usage:**      curl -X PUT https://api.us-east-1.mbedcloud.com/v2/notification/websocket -H &#39;authorization: Bearer {api-key}&#39;
     */
    public registerWebsocket(
        callback?: (error: any, data?: WebsocketChannel, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = ["application/json"];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<WebsocketChannel>(
            {
                url: "/v2/notification/websocket",
                method: "PUT",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
}
/**
 * ResourcesApi
 */
export class ResourcesApi extends ApiBase {
    /**
     * Delete a resource path
     * A request to delete a resource path must be handled by both Device Management Client and Device Management Connect.  All resource APIs are asynchronous. These APIs respond only if the device is turned on and connected to Device Management Connect and there is an active notification channel.  **Example usage:**      curl -X DELETE \\       https://api.us-east-1.mbedcloud.com/v2/endpoints/{device-id}/{resourcePath} \\       -H &#39;authorization: Bearer {api-key}&#39;
     * @param deviceId A unique Device Management device ID for the endpoint. Note that the ID must be an exact match. You cannot use wildcards here.
     * @param resourcePath The URL of the resource.
     * @param noResp If you make a request with &#x60;noResp&#x3D;true&#x60;, Device Management Connect makes a CoAP non-confirmable request to the device. Such requests are not guaranteed to arrive in the device, and you do not get back an async-response-id.  If calls with this parameter enabled succeed, they return with the status code &#x60;204 No Content&#x60;. If the underlying protocol does not support non-confirmable requests, or if the endpoint is registered in queue mode, the response is status code &#x60;409 Conflict&#x60;.
     */
    public deleteResourcePath(
        deviceId: string,
        resourcePath: string,
        noResp?: boolean,
        callback?: (error: any, data?: AsyncID, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }
        // verify required parameter "resourcePath" is set
        if (resourcePath === null || resourcePath === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'resourcePath' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (noResp !== undefined) {
            queryParameters["noResp"] = noResp;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<AsyncID>(
            {
                url: "/v2/endpoints/{device-id}/{resourcePath}"
                    .replace("{" + "device-id" + "}", String(deviceId))
                    .replace("{" + "resourcePath" + "}", String(resourcePath)),
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Execute a function on a Resource or create new Object instance
     * With this API, you can [execute a function](/docs/current/connecting/handle-resource-webapp.html#the-execute-operation) on an existing resource and create new Object instance to the device. The resource-path does not have to exist - it can be created by the call. The maximum length of resource-path is 255 characters.  All resource APIs are asynchronous. These APIs respond only if the device is turned on and connected to Device Management Connect and there is an active notification channel.  Supported content types depend on the device and its resource. Device Management translates HTTP to equivalent CoAP content type.  **Example usage:**  This example resets the min and max values of the [temperature sensor](http://www.openmobilealliance.org/tech/profiles/lwm2m/3303.xml) instance 0 by executing the Resource 5605 &#39;Reset Min and Max Measured Values&#39;.      curl -X POST \\       https://api.us-east-1.mbedcloud.com/v2/endpoints/{device-id}/3303/0/5605 \\       -H &#39;authorization: Bearer {api-key}&#39;
     * @param deviceId A unique Device Management device ID for the endpoint. Note that the ID must be an exact match. You cannot use wildcards here.
     * @param resourcePath The URL of the resource.
     * @param resourceFunction This value is not needed. Most of the time resources do not accept a function but they have their own functions predefined. You can use this to trigger them.  If a function is included, the body of this request is passed as a char* to the function in Device Management Client.
     * @param noResp If you make a request with &#x60;noResp&#x3D;true&#x60;, Device Management Connect makes a CoAP non-confirmable request to the device. Such requests are not guaranteed to arrive in the device, and you do not get back an async-response-id.  If calls with this parameter enabled succeed, they return with the status code &#x60;204 No Content&#x60;. If the underlying protocol does not support non-confirmable requests, or if the endpoint is registered in queue mode, the response is status code &#x60;409 Conflict&#x60;.
     */
    public executeOrCreateResource(
        deviceId: string,
        resourcePath: string,
        resourceFunction?: string,
        noResp?: boolean,
        callback?: (error: any, data?: AsyncID, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }
        // verify required parameter "resourcePath" is set
        if (resourcePath === null || resourcePath === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'resourcePath' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (noResp !== undefined) {
            queryParameters["noResp"] = noResp;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "text/plain",
            "application/xml",
            "application/octet-stream",
            "application/exi",
            "application/json",
            "application/link-format",
            "application/senml+json",
            "application/nanoservice-tlv",
            "application/vnd.oma.lwm2m+text",
            "application/vnd.oma.lwm2m+opaq",
            "application/vnd.oma.lwm2m+tlv",
            "application/vnd.oma.lwm2m+json",
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<AsyncID>(
            {
                url: "/v2/endpoints/{device-id}/{resourcePath}"
                    .replace("{" + "device-id" + "}", String(deviceId))
                    .replace("{" + "resourcePath" + "}", String(resourcePath)),
                method: "POST",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body: resourceFunction,
            },
            callback
        );
    }
    /**
     * Read from a resource
     * Requests the resource value either from the device or cache. If the value is not in the cache, the request goes all the way to the device. When the response is available, an &#x60;AsyncIDResponse&#x60; json object is received in the notification channel. The resource values can be also in cache based on &#x60;max_age&#x60; defined by the device side. The value found from the cache is returned immediately in the response.  The preferred way to get resource values is to use the **subscribe** and **callback** methods.  All resource APIs are asynchronous. These APIs only respond if the device is turned on and connected to Device Management.  See also how [resource caching](/docs/current/connecting/device-guidelines.html#resource-cache) works.  Please refer to [Lightweight Machine to Machine Technical specification](http://www.openmobilealliance.org/release/LightweightM2M/V1_0-20170208-A/OMA-TS-LightweightM2M-V1_0-20170208-A.pdf) for more inforamtion.  **Example usage:**      curl -X GET \\       https://api.us-east-1.mbedcloud.com/v2/endpoints/{device-id}/{resourcePath} \\       -H &#39;authorization: Bearer {api-key}&#39;
     * @param deviceId Unique Device Management device ID for the endpoint. Note that the ID needs to be an exact match. You cannot use wildcards here.
     * @param resourcePath The URL of the resource.
     * @param cacheOnly If true, the response comes only from the cache. Default: false. Device Management Connect caches the received resource values for the time of [max_age](/docs/current/connecting/working-with-the-resources.html) defined in the client side.
     * @param noResp If a request is made with &#x60;noResp&#x3D;true&#x60;, Device Management Connect makes a CoAP non-confirmable request to the device. Such requests are not guaranteed to arrive in the device, and you do not get back an async-response-id.  If calls with this parameter enabled succeed, they return with the status code &#x60;204 No Content&#x60;. If the underlying protocol does not support non-confirmable requests, or if the endpoint is registered in queue mode, the response is status code &#x60;409 Conflict&#x60;.
     */
    public getResourceValue(
        deviceId: string,
        resourcePath: string,
        cacheOnly?: boolean,
        noResp?: boolean,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }
        // verify required parameter "resourcePath" is set
        if (resourcePath === null || resourcePath === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'resourcePath' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (cacheOnly !== undefined) {
            queryParameters["cacheOnly"] = cacheOnly;
        }
        if (noResp !== undefined) {
            queryParameters["noResp"] = noResp;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/endpoints/{device-id}/{resourcePath}"
                    .replace("{" + "device-id" + "}", String(deviceId))
                    .replace("{" + "resourcePath" + "}", String(resourcePath)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Write to a Resource or use write-attributes (notification rules) for a Resource
     * With this API, you can [write a new value to existing Resources](/docs/current/connecting/handle-resource-webapp.html) or use the **write** attributes to set the [notification rules](/docs/current/connecting/resource-change-webapp.html#notification-rules) for the Resources. The notification rules only work on the device client side and may not be supported by all clients.  This API can also be used to transfer files to the device. Device Management Connect LwM2M server implements the Option 1 from RFC7959. The maximum block size is 1024 bytes. The block size versus transferred file size is something to note in low quality networks. The customer application needs to know what type of file is transferred (for example txt) and the payload can be encrypted by the customer. The maximum size of payload is 1048576 bytes.  All resource APIs are asynchronous. These APIs respond only if the device is turned on and connected to Device Management Connect and there is an active notification channel.  Supported content types depend on the device and its resource. Device Management translates HTTP to equivalent CoAP content type.  **Example usage:**  This example sets the alarm on a buzzer. The command writes the [Buzzer](http://www.openmobilealliance.org/tech/profiles/lwm2m/3338.xml) instance 0, \&quot;On/Off\&quot; boolean resource to &#39;1&#39;.      curl -X PUT \\       https://api.us-east-1.mbedcloud.com/v2/endpoints/{device-id}/3338/0/5850 -H \&quot;content-type: text/plain\&quot; \\       -H &#39;authorization: Bearer {api-key}&#39; -d &#39;1&#39;
     * @param deviceId A unique Device Management device ID for the endpoint. Note that the ID must be an exact match. You cannot use wildcards here.
     * @param resourcePath Resource URL.
     * @param resourceValue The value to be set to the resource.
     * @param noResp If you make a request with &#x60;noResp&#x3D;true&#x60;, Device Management Connect makes a CoAP non-confirmable request to the device. Such requests are not guaranteed to arrive in the device, and you do not get back an async-response-id.  If calls with this parameter enabled succeed, they return with the status code &#x60;204 No Content&#x60;. If the underlying protocol does not support non-confirmable requests, or if the endpoint is registered in queue mode, the response is status code &#x60;409 Conflict&#x60;.
     */
    public updateResourceValue(
        deviceId: string,
        resourcePath: string,
        resourceValue: string,
        noResp?: boolean,
        callback?: (error: any, data?: AsyncID, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }
        // verify required parameter "resourcePath" is set
        if (resourcePath === null || resourcePath === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'resourcePath' missing."));
            }
            return;
        }
        // verify required parameter "resourceValue" is set
        if (resourceValue === null || resourceValue === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'resourceValue' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};
        if (noResp !== undefined) {
            queryParameters["noResp"] = noResp;
        }

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [
            "text/plain",
            "application/xml",
            "application/octet-stream",
            "application/exi",
            "application/json",
            "application/link-format",
            "application/senml+json",
            "application/nanoservice-tlv",
            "application/vnd.oma.lwm2m+text",
            "application/vnd.oma.lwm2m+opaq",
            "application/vnd.oma.lwm2m+tlv",
            "application/vnd.oma.lwm2m+json",
        ];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<AsyncID>(
            {
                url: "/v2/endpoints/{device-id}/{resourcePath}"
                    .replace("{" + "device-id" + "}", String(deviceId))
                    .replace("{" + "resourcePath" + "}", String(resourcePath)),
                method: "PUT",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body: resourceValue,
            },
            callback
        );
    }
}
/**
 * SubscriptionsApi
 */
export class SubscriptionsApi extends ApiBase {
    /**
     * Subscribe to a resource path
     * The Device Management Connect eventing model consists of observable resources.  This means that endpoints can deliver updated resource content, periodically or with a more sophisticated solution-dependent logic. The OMA LwM2M resource model including objects, object instances, resources and resource instances is also supported.  Applications can subscribe to objects, object instances or individual resources to make the device to provide value change notifications to Device Management Connect service. An application needs to call a &#x60;/notification/callback&#x60; method to get Device Management Connect to push notifications of the resource changes.  **Notification rules**  A web application can place dynamic observation rules for individual Object Instances and Resources to define when the device sends observations. More information in [Notification rules](/docs/current/connecting/resource-change-webapp.html).  All manual subscriptions are removed during a full device registration and applications need to re-subscribe at that point. To avoid this, you can use &#x60;/subscriptions&#x60; to set a pre-subscription.  **Example usage:**      curl -X PUT \\       https://api.us-east-1.mbedcloud.com/v2/subscriptions/{device-id}/{resourcePath} \\       -H &#39;authorization: Bearer {api-key}&#39;
     * @param deviceId A unique Device Management device ID for the endpoint. Note that the ID must be an exact match. You cannot use wildcards here.
     * @param resourcePath The URL of the resource.
     */
    public addResourceSubscription(
        deviceId: string,
        resourcePath: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }
        // verify required parameter "resourcePath" is set
        if (resourcePath === null || resourcePath === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'resourcePath' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<null>(
            {
                url: "/v2/subscriptions/{device-id}/{resourcePath}"
                    .replace("{" + "device-id" + "}", String(deviceId))
                    .replace("{" + "resourcePath" + "}", String(resourcePath)),
                method: "PUT",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Read subscription status
     * @param deviceId A unique Device Management device ID for the endpoint. Note that the ID must be an exact match. You cannot use wildcards here.
     * @param resourcePath The URL of the resource.
     */
    public checkResourceSubscription(
        deviceId: string,
        resourcePath: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }
        // verify required parameter "resourcePath" is set
        if (resourcePath === null || resourcePath === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'resourcePath' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/subscriptions/{device-id}/{resourcePath}"
                    .replace("{" + "device-id" + "}", String(deviceId))
                    .replace("{" + "resourcePath" + "}", String(resourcePath)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Delete subscriptions from an endpoint
     * Deletes all resource subscriptions in a single endpoint.  **Example usage:**      curl -X DELETE \\       https://api.us-east-1.mbedcloud.com/v2/subscriptions/{device-id} \\       -H &#39;authorization: Bearer {api-key}&#39;
     * @param deviceId A unique Device Management device ID for the endpoint. Note that the ID must be an exact match. You cannot use wildcards here.
     */
    public deleteEndpointSubscriptions(
        deviceId: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/subscriptions/{device-id}".replace("{" + "device-id" + "}", String(deviceId)),
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Remove pre-subscriptions
     * Removes pre-subscriptions.  **Example usage:**      curl -X DELETE https://api.us-east-1.mbedcloud.com/v2/subscriptions -H &#39;authorization: Bearer {api-key}&#39;
     */
    public deletePreSubscriptions(
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/subscriptions",
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Remove a subscription
     * To remove an existing subscription from a resource path.  **Example usage:**      curl -X DELETE \\       https://api.us-east-1.mbedcloud.com/v2/subscriptions/{device-id}/{resourcePath} \\       -H &#39;authorization: Bearer {api-key}&#39;
     * @param deviceId A unique Device Management device ID for the endpoint. Note that the ID must be an exact match. You cannot use wildcards here.
     * @param resourcePath The URL of the resource.
     */
    public deleteResourceSubscription(
        deviceId: string,
        resourcePath: string,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }
        // verify required parameter "resourcePath" is set
        if (resourcePath === null || resourcePath === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'resourcePath' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = [];

        return this.request<null>(
            {
                url: "/v2/subscriptions/{device-id}/{resourcePath}"
                    .replace("{" + "device-id" + "}", String(deviceId))
                    .replace("{" + "resourcePath" + "}", String(resourcePath)),
                method: "DELETE",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Read endpoints subscriptions
     * Lists all subscribed resources from a single endpoint.  **Example usage:**      curl -X GET \\       https://api.us-east-1.mbedcloud.com/v2/subscriptions/{device-id} \\       -H &#39;authorization: Bearer {api-key}&#39;
     * @param deviceId A unique Device Management device ID for the endpoint. Note that ID must be an exact match. You cannot use wildcards here.
     */
    public getEndpointSubscriptions(
        deviceId: string,
        callback?: (error: any, data?: string, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "deviceId" is set
        if (deviceId === null || deviceId === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'deviceId' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["text/uri-list"];

        return this.request<string>(
            {
                url: "/v2/subscriptions/{device-id}".replace("{" + "device-id" + "}", String(deviceId)),
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Get pre-subscriptions
     * You can retrieve the pre-subscription data with the GET operation. The server returns with the same JSON structure as described above. If there are no pre-subscribed resources, it returns with an empty array.  **Example usage:**      curl -X GET https://api.us-east-1.mbedcloud.com/v2/subscriptions -H &#39;authorization: Bearer {api-key}&#39;
     */
    public getPreSubscriptions(
        callback?: (error: any, data?: PresubscriptionArray, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = [];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["application/json"];

        return this.request<PresubscriptionArray>(
            {
                url: "/v2/subscriptions",
                method: "GET",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
            },
            callback
        );
    }
    /**
     * Set pre-subscriptions
     * Pre-subscription is a set of rules and patterns put by the application. When an endpoint registers and its ID, type and registered resources match the pre-subscription data, Device Management Connect sends subscription requests to the device automatically. The pattern may include the endpoint ID (optionally having an &#x60;*&#x60; character at the end), endpoint type, a list of resources or expressions with an &#x60;*&#x60; character at the end. Subscriptions based on pre-subscriptions are done when device registers or does register update. To remove the pre-subscription data, put an empty array as a rule.  **Notification rules**  A web application can place dynamic observation rules for individual Object Instances and Resources to define when the device sends observations. More information in [Notification rules](/docs/current/connecting/resource-change-webapp.html).  **Limits**:  - The maximum length of the endpoint name and endpoint type is 64 characters. - The maximum length of the resource path is 128 characters. - You can listen to 256 separate resource paths. - The maximum number of pre-subscription entries is 1024.  **Example request:**  &#x60;&#x60;&#x60; curl -X PUT \\   https://api.us-east-1.mbedcloud.com/v2/subscriptions \\   -H &#39;authorization: Bearer {api-key}&#39; \\   -H &#39;content-type: application/json&#39; \\   -d &#39;[          {            \&quot;endpoint-name\&quot;: \&quot;node-001\&quot;,            \&quot;resource-path\&quot;: [\&quot;/dev\&quot;]          },          {            \&quot;endpoint-type\&quot;: \&quot;Light\&quot;,            \&quot;resource-path\&quot;: [\&quot;/sen/_*\&quot;]          },          {            \&quot;endpoint-name\&quot;: \&quot;node*\&quot;          },          {            \&quot;endpoint-type\&quot;: \&quot;Sensor\&quot;          },          {            \&quot;resource-path\&quot;: [\&quot;/dev/temp\&quot;,\&quot;/dev/hum\&quot;]          }       ]&#39; &#x60;&#x60;&#x60;  - Subscribe to &#x60;/dev&#x60; resource of endpoint named &#x60;node-001&#x60;. - Subscribe to &#x60;Light&#x60; type of endpoints and their resources prefixed with &#x60;/sen/&#x60;. - Subscribe to all observable resources of endpoint names prefixed with &#x60;node&#x60;. - Subscribe to all observable resources of &#x60;Sensor&#x60; type endpoints. - Subscribe to &#x60;/dev/temp&#x60; and &#x60;/dev/hum&#x60; resources of all endpoints.  **Note**: For efficiency reasons, you should use resource path patterns in the pre-subscription data. This prevents the notification flow from unwanted resources.
     * @param presubsription Array of pre-subscriptions.
     */
    public updatePreSubscriptions(
        presubsription: PresubscriptionArray,
        callback?: (error: any, data?: any, response?: superagent.Response) => any,
        requestOptions?: { [key: string]: any }
    ): superagent.SuperAgentRequest {
        // verify required parameter "presubsription" is set
        if (presubsription === null || presubsription === undefined) {
            if (callback) {
                callback(new SDKError("Required parameter 'presubsription' missing."));
            }
            return;
        }

        const headerParams: any = {};

        const queryParameters: any = {};

        // tslint:disable-next-line:prefer-const
        let useFormData = false;
        const formParams: any = {};

        // Determine the Content-Type header
        const contentTypes: Array<string> = ["application/json"];

        // Determine the Accept header
        const acceptTypes: Array<string> = ["text/plain"];

        return this.request<null>(
            {
                url: "/v2/subscriptions",
                method: "PUT",
                headers: headerParams,
                query: queryParameters,
                formParams,
                useFormData,
                contentTypes,
                acceptTypes,
                requestOptions,
                body: presubsription,
            },
            callback
        );
    }
}
