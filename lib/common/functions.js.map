{"version":3,"sources":["common/functions.ts"],"names":[],"mappings":"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","file":"functions.js","sourcesContent":["/*\n* Mbed Cloud JavaScript SDK\n* Copyright Arm Limited 2017\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\nimport { CallbackFn, ComparisonObject, operators } from \"./interfaces\";\nimport { SDKError } from \"./sdkError\";\nimport { decodeTlv } from \"./tlvDecoder\";\n\n// Inspired by https://github.com/sonnyp/polygoat\n// If a callback is passed, use that after running the passed function, otherwise return a promise chain\nexport function asyncStyle<T>(asyncFn: (done: CallbackFn<T>) => void, callbackFn?: CallbackFn<T>): Promise<T> {\n    if (callbackFn) {\n        try {\n            asyncFn(callbackFn);\n        } catch (error) {\n            callbackFn(new SDKError(error.message, error));\n        }\n    } else {\n        return new Promise((resolve, reject) => {\n            try {\n                asyncFn((error: SDKError, response: T) => {\n                    if (error) reject(error);\n                    else resolve(response);\n                });\n            } catch (error) {\n                reject(new SDKError(error.message, error));\n            }\n        });\n    }\n}\n\n// Wrap our functions to allow error catching\n// Wraps an api function call and optionally a data transformation function to allow a single point for trapping errors\nexport function apiWrapper<T>(\n    apiFn: (resultsFn: (error: any, data: any) => void) => void,\n    transformFn?: (data: any, resultsFn: (error: SDKError, result: T) => void) => void,\n    callbackFn?: CallbackFn<T>,\n    failOnNotFound = false\n): Promise<T> {\n    // Use async style\n    return asyncStyle(done => {\n        try {\n            // Call the api function\n            apiFn((error, data) => {\n                if (error) {\n                    if (!failOnNotFound && error.code === 404) {\n                        return done(null, null);\n                    } else {\n                        return done(error);\n                    }\n                }\n\n                if (!transformFn) return done(null, data);\n\n                try {\n                    // Call the transformation function\n                    transformFn(data, done);\n                } catch (error) {\n                    // Catch any errors when transforming the returned data\n                    done(new SDKError(error.message, error));\n                }\n            });\n        } catch (error) {\n            // Catch any errors when running api calls\n            done(new SDKError(error.message, error));\n        }\n    }, callbackFn);\n}\n\nexport function decodeBase64(payload, contentType): string | number | { [key: string]: string | number } {\n    // any so can be used in .isNaN method\n    let result: any = \"\";\n\n    // Decode Base64\n    if (typeof atob === \"function\") {\n        result = atob(payload);\n    } else {\n        result = new Buffer(payload, \"base64\").toString(\"binary\");\n    }\n\n    // According to the swagger, content types can be:\n    // text/plain\n    // application/xml\n    // application/octet-stream\n    // application/exi\n    // application/json\n    // application/link-format\n    // application/senml+json\n    // application/nanoservice-tlv\n    // application/vnd.oma.lwm2m+text\n    // application/vnd.oma.lwm2m+opaq\n    // application/vnd.oma.lwm2m+tlv\n    // application/vnd.oma.lwm2m+json\n    if (contentType) {\n        if (contentType.indexOf(\"tlv\") > -1) {\n            // Decode tlv\n            try {\n                return decodeTlv(result);\n            // tslint:disable-next-line:no-empty\n            } catch (e) {}\n        }\n        /*\n        else if (contentType.indexOf(\"json\") > -1) {\n            // Decode json\n            try {\n                return JSON.parse(result);\n            } catch(e) {}\n        }\n        */\n    }\n\n    // if string value is a number, then return number, otherwise just return the string\n    return !isNaN(result) ? Number(result) : result;\n}\n\nexport function encodeInclude(include) {\n    if (!include || !include.length) return null;\n    return include.map(camelToSnake).join(\",\");\n}\n\nexport function snakeToCamel(snake) {\n    return snake.replace(/(\\_\\w)/g, match => {\n        return match[1].toUpperCase();\n    });\n}\n\nexport function camelToSnake(camel) {\n    return camel.replace(/([A-Z]+?)/g, match => {\n        return \"_\" + match.toLowerCase();\n    });\n}\n\nexport function extractFilter(filter: { [key: string]: ComparisonObject<any> | string }, name: string, operator: operators = \"$eq\", defaultValue: any = null): any {\n\n    if (filter && filter[name]) {\n        const value = filter[name];\n        if (value.constructor !== {}.constructor) return value;\n\n        switch (operator) {\n        case \"$ne\": {\n            if ((value as ComparisonObject<any>).$ne) return (value as ComparisonObject<any>).$ne;\n            break;\n        }\n        case \"$gte\": {\n            if ((value as ComparisonObject<any>).$gte) return (value as ComparisonObject<any>).$gte;\n            break;\n        }\n        case \"$lte\": {\n            if ((value as ComparisonObject<any>).$lte) return (value as ComparisonObject<any>).$lte;\n            break;\n        }\n        case \"$in\": {\n            if ((value as ComparisonObject<any>).$in) return (value as ComparisonObject<any>).$in;\n            break;\n        }\n        case \"$nin\": {\n            if ((value as ComparisonObject<any>).$nin) return (value as ComparisonObject<any>).$nin;\n            break;\n        }\n        default: {\n            if ((value as ComparisonObject<any>).$eq) return (value as ComparisonObject<any>).$eq;\n            break;\n        }\n        }\n    }\n\n    return defaultValue;\n}\n\nexport function encodeFilter(filter: { [key: string]: ComparisonObject<any> | string | {} }, map: { from: Array<string>, to: Array<string> } = { from: [], to: [] }, nested: Array<string> = []): string {\n    if (!filter) return \"\";\n\n    function encode(name, operator, value, prefix: string = \"\") {\n        if (value instanceof Date) value = value.toISOString();\n        if (typeof value === \"boolean\") value = value.toString();\n\n        if (prefix) {\n            prefix = camelToSnake(prefix);\n            prefix = `${prefix}__`;\n        } else {\n            // Don't encode nested names\n            const index = map.from.indexOf(name);\n            name = (index > -1) ? map.to[index] : camelToSnake(name);\n        }\n\n        let suffix = operator.replace(\"$\", \"\");\n        if (suffix === \"ne\") suffix = \"neq\";\n        if (suffix === \"eq\") suffix = \"\"; // Needs to removed when implemented properly in APIs\n        if (suffix) suffix = `__${suffix}`;\n\n        return `${prefix}${name}${suffix}=${value}`;\n    }\n\n    return Object.keys(filter).map(key => {\n        // Support bare { key: value }\n        if (filter[key].constructor !== {}.constructor) return encode(key, \"\", filter[key]);\n\n        return Object.keys(filter[key]).map(operator => {\n            if (nested.indexOf(key) > -1) {\n                // Support bare { key: value }\n                if (filter[key][operator].constructor !== {}.constructor) return encode(operator, \"\", filter[key][operator], key);\n\n                return Object.keys(filter[key][operator]).map(sub => {\n                    return encode(operator, sub, filter[key][operator][sub], key);\n                }).join(\"&\");\n            }\n            return encode(key, operator, filter[key][operator]);\n        }).join(\"&\");\n    }).join(\"&\");\n}\n\nexport function decodeFilter(from: string, map: { from: Array<string>, to: Array<string> } = { from: [], to: [] }, nested: Array<string> = []): { [key: string]: ComparisonObject<any> | {} } {\n    const filter: { [key: string]: ComparisonObject<any> } = {};\n\n    function decodeName(name: string): string {\n        const index = map.to.indexOf(name);\n        return (index > -1) ? map.from[index] : snakeToCamel(name);\n    }\n\n    function addOperator(comparisonObject: {}, operator: string, value: string) {\n        if (!operator) operator = \"eq\"; // Needs to removed when implemented properly in APIs\n        if (operator === \"neq\") operator = \"ne\";\n        operator = `$${operator}`;\n        comparisonObject[operator] = value;\n    }\n\n    from = decodeURIComponent(from);\n    from.split(\"&\").forEach(attrib => {\n        const match = attrib.match(/^(.+)=(.+)$/);\n        if (match) {\n            const value = match[2];\n            const bits = match[1].split(\"__\");\n\n            const name = decodeName(bits[0]);\n            if (!filter[name]) filter[name] = {};\n\n            if (nested.indexOf(name) > -1) {\n                const nestedName = bits[1]; // Don't decode nested names\n                if (!filter[name][nestedName]) filter[name][nestedName] = {};\n                addOperator(filter[name][nestedName], bits[2], value);\n                return;\n            }\n\n            addOperator(filter[name], bits[1], value);\n        }\n    });\n\n    return filter;\n}\n\nexport function ensureArray<T>(item: T | Array<T>): Array<T> {\n    return item instanceof Array ? item : [ item ];\n}\n\nexport function matchWithWildcard(input: string, matchWith: string): boolean {\n    // if we have nothing to match with, return false\n    if (matchWith === null || matchWith === undefined || matchWith === \"\") {\n        return false;\n    }\n\n    // if input is empty or * then we're listening to everything so return true\n    if (input === null || input === undefined || input === \"\" || input === \"*\") {\n        return true;\n    }\n\n    // if wildcard used, match on begining of string\n    if (input.endsWith(\"*\")) {\n        return matchWith.startsWith(input.slice(0, -1));\n    }\n\n    // no wildcard so match strings explicitly\n    return input === matchWith;\n}\n\nexport function dateToBillingMonth(date: Date) {\n    // make sure date is actually a Date object;\n    date = new Date(date);\n    return `${date.getFullYear()}-${(\"0\" + (date.getMonth() + 1)).slice(-2)}`;\n}\n"],"sourceRoot":"../../src"}